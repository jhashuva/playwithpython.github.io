{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Play with Python Install Python Create Github account Python first steps Scalar data types collections Comprehensions Shallow copy and Deep copy Functions Variable scopes","title":"Home"},{"location":"#welcome-to-play-with-python","text":"Install Python Create Github account Python first steps Scalar data types collections Comprehensions Shallow copy and Deep copy Functions Variable scopes","title":"Welcome to Play with Python"},{"location":"collections/","text":"Collections Strings: str Str is the short form of string Str data type is immutable i.e once you declare it, you cannot able to modify it. Syntax: >>>\"this is string\" 'this is string' >>>'this is also a string' 'this is also a string' >>>\"This is not way of declering the string' File \"<stdin>\", line 1 \"This is not way of declering the string' ^ SyntaxError: EOL while scanning string literal >>>'This is also not way of declering the string\" File \"<stdin>\", line 1 'This is also not way of declering the string\" ^ SyntaxError: EOL while scanning string literal You can check the data type of the string >>>a = \"paly with python\" >>>type(a) <class 'str'> String with new lines: Multi line strings: spread the literal across multipule lines. >>>\"\"\" This is ... multi line string ... this is end\"\"\" 'This is\\nmulti line string\\nthis is end' >>> poem = \"\"\"Just like moons and like suns, ... With the certainity of tides, ... Just like hopes springing high, ... Still I'll raise.\"\"\" >>> poem 'Just like moons and like suns,\\nWith the certainity of tides,\\nJust like hopes springing high,\\nStill I'll raise.' >>> print(poem) Just like moons and like suns, With the certainity of tides, Just like hopes springing high, Still I'll raise. Escape sequences : Embed escape sequences in a single-line literal Python lets you escape the meaning of some characters with in strings to achieve effects that would otherwise be difficult to express.By preceding a character with a backslash (), you give it a special meaning.The most common escape sequence is \\n,which means to begin a new line. >>> 'This is\\nmulti line string\\nthis is end' 'This is\\nmulti line string\\nthis is end' >>> a = 'You are not your parents\\nYou are not your class\\nYou are not the clothes you wear\\nYou are not the size of your friend circle\\nYour sum of your words. choices and actions.' >>> a 'You are not your parents\\nYou are not your class\\nYou are not the clothes you wear\\nYou are not the size of your friend circle\\nYour sum of your words. choices and actions.' >>> print(a) You are not your parents You are not your class You are not the clothes you wear You are not the size of your friend circle Your sum of your words. choices and actions. More escape sequences: >>> palindrome = 'A man,\\nA plan,\\nA canal:\\nPanama.' >>> print(palindrome) A man, A plan, A canal: Panama. >>> print('\\tabc') abc >>> print('a\\tbc') a bc >>> print('ab\\tc') ab c >>> testimony = \"\\\"I did nothing!\\\" he said. \\\"Or that other thing.\\\"\" >>> print(testimony) \"I did nothing!\" he said. \"Or that other thing.\" >>> fact = \"The world's largest rubber duck was 54'2\\\" by 65'7\\\" by 105'\" >>> print(fact) The world's largest rubber duck was 54'2\" by 65'7\" by 105' >>> speech = 'The backslash (\\\\) can be printed using like this.' >>> print(speech) The backslash (\\) can be printed using like this. Combining by using + we can combine literal strings or string variables using the + operator. >>> \"good \"+\"morning\" 'good morning' >>> name = \"Joe\" >>> branch = \" computer science and engineering\" >>> print(name+branch) Joe computer science and engineering >>> a = 'Duck.' >>> b = a >>> c = 'Grey Duck!' >>> a+b+c 'Duck.Duck.Grey Duck!' Duplicate with * We use the * operator to duplicate a string. >>> \"hi\"*3 'hihihi' >>> \"hello \"*3 'hello hello hello' >>> a = 'Na ' * 4 + '\\n' >>> b = 'Hey ' * 3 + '\\n' >>> end = 'Goodbye.' >>> print(start + start + middle + end) Na Na Na Na Na Na Na Na Hey Hey Hey Goodbye. Notice that the * has higher precedence than +, so the string is duplicated before the line feed is tacked on. Get characters with [] To get a single character from a string, specify its offset inside square brackets after the string\u2019s name. The first (leftmost) offset is 0, the next is 1, and so on. >>> letters = 'abcdefghijklmnopqrstuvwxyz' >>> letters[0] a >>> letters[25] z Get a substring with a slice syntax: [start_offset:end_offset:step(optional)] >>> letters[1:11] 'bcdefghijk' >>> letters[1:20:2] 'bdfhjlnprt' >>> letters[::5] 'afkpuz' >>> letters[21] 'v' Get Length with len() The len() function counts characters in a string: Syntax: len(string) >>> letters = 'abcdefghijklmnopqrstuvwxyz' >>> len(letters) 26 >>> empty = \"\" >>> len(empty) 0 spilt with split() You can use the built-in string split() function to break a string into a list of smaller strings based on some separator. syntax: string.split('seperator') >>> tasks = 'get gloves,get mask,give cat vitamins,call ambulance' >>> tasks.split(',') ['get gloves', 'get mask', 'give cat vitamins', 'call ambulance'] >>> tasks.split() ['get', 'gloves,get', 'mask,give', 'cat', 'vitamins,call', 'ambulance'] combine by using join() syntax: seperator.join(list) >>> crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster'] >>> crypto_string = ', '.join(crypto_list) >>> print(crypto_string) Yeti, Bigfoot, Loch Ness Monster Substitute by Using replace() You use replace() for simple substring substitution.Give it the old substring, the new one,and how many instances of the old substring to replace. It returns the changed string but does notmodify the original string.If you omit this final count argument, it replaces all instances. Syntax: string.replace(old_substring, new_substring, count(optional)) >>> setup = \"a duck goes into a bar...\" >>> setup.replace('duck', 'marmoset') >>> setup.replace('duck', 'marmoset') 'a marmoset goes into a bar...' >>> setup 'a duck goes into a bar...' Strip with strip() The strip() functions shown here assume that you want to get rid ofwhitespace characters (' ', '\\t', '\\n')if you don\u2019t give them an argument.strip() str. strip() strips both ends, lstrip() only from the left, and rstrip() only from the right. Syntax : string.strip() >>> world = \" earth \" >>> world.strip() 'earth' >>> world.strip(' ') 'earth' >>> world.lstrip() 'earth ' >>> world.rstrip() ' earth' If the character were not there, nothing happens: >>> world.strip('!') ' earth ' Besides no argument (meaning whitespace characters) or a single character, you can also tell strip() to remove any character in a multicharacter string: >>> blurt = \"What the...!!?\" >>> blurt.strip('.?!') 'What the' Search and Select >>> poem = '''All that doth flow we cannot liquid name ... Or else would fire and water be the same; ... But that is liquid which is moist and wet ... Fire that property can never get .... Then 'tis not cold that doth the fire put out ... But 'tis the wet that makes it die, no doubt.''' >>> poem[:13] 'All that doth' >>> len(poem) 254 >>> poem.startswith('All') True >>> poem.endswith('That\\'s all, folks!') False Let\u2019s find the offset of the first occurrenceof the word the in the poem: >>> word='the' >>> poem.find(word) 73 >>> poem.index(word) 73 And the offset of the last the: >>> word = 'the' >>> poem.rfind(word) 218 >>> poem.rindex(word) 218 How many times does the three-letter sequence 'the' occur? >>> poem.count(word) 3 Are all of the characters in the poem either letters or numbers? >>> poem.isalnum() False Cases: >>> setup = 'a duck goes into a bar...' >>> setup.strip('.') 'a duck goes into a bar' Capitalize the first word: >>> setup.capitalize() 'A duck goes into a bar...' Capitalize all the words: >>> setup.title() 'A Duck Goes Into A Bar...' Convert all characters to uppercase: >>> setup.upper() 'A DUCK GOES INTO A BAR...' Convert all characters to lowercase: >>> setup.lower() 'a duck goes into a bar...' Swap uppercase and lowercase: >>> setup.swapcase() 'A DUCK GOES INTO A BAR...' >>> setup 'a duck goes into a bar...' Formatting : %s string %d decimal integer %x hex integer %o octal integer %f decimal float %e exponential float %g decimal or exponential float You can use a %s for any data type, and Python will format it as a string with no extra spaces. >>> '%s' % 42 '42' >>> '%d' % 42 '42' >>> '%x' % 42 '2a' >>> '%o' % 42 '52' An integer and a literal %: >>> '%d%%' % 100 '100%' Let's try some string and integer interpolation: >>> actor = 'Richard Gere' >>> cat = 'Chester' >>> weight = 28 >>> \"My friend's favorite actor is %s\" % actor \"My friend's favorite actor is Richard Gere\" >>> \"Our cat %s weighs %d pounds\" % (cat, weight) 'Our cat Chester weighs 28 pounds' some more examples >>> thing = 'woodchuck' >>> '%s' % thing 'woodchuck' >>> '%12s' % thing ' woodchuck' >>> '%+12s' % thing ' woodchuck' >>> '%-12s' % thing 'woodchuck ' >>> '%.3s' % thing 'woo' >>> '%12.3s' % thing ' woo' >>> '%-12.3s' % thing 'woo ' one more with feeling >>> thing = 98.6 >>> '%f' % thing '98.600000' >>> '%12f' % thing ' 98.600000' >>> '%6f' % thing '98.600000' >>> '%+12f' % thing ' +98.600000' >>> '%-12f' % thing '98.600000 ' >>> '%.3f' % thing '98.600' >>> '%12.3f' % thing ' 98.600' >>> '%-12.3f' % thing '98.600 ' New style:{} and format() \u201cNew style\u201d formatting has the form format_string.format(data). >>> thing = 'woodchuck' >>> '{}'.format(thing) 'woodchuck' The arguments to the format() function need to be in the order as the {} placeholders in the format string: >>> thing = 'woodchuck' >>> place = 'lake' >>> 'The {} is in the {}.'.format(thing, place) 'The woodchuck is in the lake.' With new-style formatting, you can also specify the arguments by position like this: >>> 'The {1} is in the {0}.'.format(place, thing) 'The woodchuck is in the lake.' The value 0 referred to the first argument, place, and 1 referred to thing. The arguments to format() can also be named arguments >>> 'The {thing} is in the {place}'.format(thing='duck', place='bathtub') 'The duck is in the bathtub' or a dictionary: >>> d = {'thing': 'duck', 'place': 'bathtub'} >>> 'The {0[thing]} is in the {0[place]}.'.format(d) 'The duck is in the bathtub.' More Examples: >>> thing = 'wraith' >>> place = 'window' >>> 'The {} is at the {}'.format(thing, place) 'The wraith is at the window' >>> 'The {:10s} is at the {:10s}'.format(thing.upper(), place) 'The WRAITH is at the window ' >>> 'The {:<10s} is at the {:<10s}'.format(thing, place) 'The wraith is at the window ' >>> 'The {:^10s} is at the {:^10s}'.format(thing, place) 'The wraith is at the window ' >>> 'The {:>10s} is at the {:>10s}'.format(thing, place) 'The wraith is at the window' >>> 'The {:!^10s} is at the {:!^10s}'.format(thing, place) 'The !!wraith!! is at the !!window!!' Newest Style: f-strings f-strings appeared in Python 3.6, and are now the recommended way of formatting strings. To make an f-string: Type the letter f or F directly before the initial quote. Include variable names or expressions within curly brackets ({}) to get their values into the string. >>> thing = 'wereduck' >>> place = 'werepond' >>> f'The {thing} is in the {place}' 'The wereduck is in the werepond' >>> f'The {thing.capitalize()} is in the {place.rjust(20)}' 'The Wereduck is in the werepond' >>> f'The {thing:>20} is in the {place:.^20}' 'The wereduck is in the ......werepond......' Starting in Python 3.8, f-strings gain a new shortcut that\u2019s helpful when you want to print variable names as well as their values. >>> f'{thing =}, {place =}' \"thing ='wereduck', place ='werepond'\" >>> f'{thing[-4:] =}, {place.title() =}' \"thing[-4:] ='duck', place.title() ='Werepond'\" >>> f'{thing = :>4.4}' 'thing = were' for more details: python documentation These examples are borrowed from the \"Introducing Python\" 2nd Edition by Bill Lubanovic, O'Reilly media inc.,2019 Think Python, Second Edition, Allen B. Downey, 2016, O'Reilly Go to top Learning check Home Bytes Data type for sequence of bytes Raw binary data Fixed width single byte encoding >>> b'byte data' b'byte data' >>> d= b'some bytes' >>> type(d) <class 'bytes'> >>> d.split() [b'some', b'bytes'] Converting between strings and bytes: >>> a = b'byte data' >>> a.decode() 'byte data' >>> b = 'hello python' >>> b.encode() b'hello python' Go to Top Home Lists sequence of objects Lists are Mutable Lists are declared with [] or list() Items are seperated with comma(,) Create empty list >>> myfirst_list = [] # one way of creating empty list >>> type(myfirst_list) <class 'list'> >>> mysecond_list = list() # another way of creating empty list >>> type(mysecond_list) <class 'list'> python list() converts string into list >>> list('python') ['p', 'y', 't', 'h', 'o', 'n'] Create a list from string split() >>> python_day='12/12/2019' >>> python_day.split('/') ['12', '12', '2019'] list.reverse() : To reverse the elements in the list >>> lang=['c','c++','java','python'] >>> lang.reverse() >>> lang ['python', 'java', 'c++', 'c'] Add an Item to the End with append() >>> lang=['c','c++','java','python'] >>> lang.append('R') >>> lang ['c', 'c++', 'java', 'python', 'R'] Add an Item by Offset with insert() syntax: insert(index, word) Examples: >>> lang=['c', 'c++', 'java', 'python', 'R'] >>> lang.insert(2,'scala') >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R'] Duplicate All Items with * syntax: ['string']*value Examples: >>> ['python']*3 ['python', 'python', 'python'] >>> ['python','java']*3 ['python', 'java', 'python', 'java', 'python', 'java'] Combine Lists by Using extend() or + >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R'] >>> markups=['html','xml'] >>> lang.extend(markups) >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml'] >>> server_scripting=['PHP','ASP','JSP'] >>> lang=lang+server_scripting >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP'] >>> lang+=server_scripting >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP'] >>> client_scripting=['javascript','actionscript'] >>> lang.append(client_scripting) >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] Change an Item by [offset] >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] >>> lang[1]='c#' >>> lang ['c', 'c#', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] ``` Change an item with slice ```python >>> numbers=[1,2,3,4] >>> numbers[1:3]=[8,9] >>> numbers [1, 8, 9, 4] Delete an Item by Offset with del syntax: del list[offset] Examples: >>> languages=['C','C#','Java','Python'] >>> del languages[-1] >>> languages ['C', 'C#', 'Java'] >>> del languages[0:2] >>> languages ['Java'] Delete an Item by Value with remove() syntax: list.remove('element') Examples: >>> languages=['C','C#','Java','Python'] >>> languages.remove('C#') Get an Item Offset and Delete It with pop() syntax: list.pop(offset) >>> languages=['C','C#','Java','Python'] >>> languages.pop() 'Python' >>> languages.pop(1) 'C#' >>> languages ['C', 'Java'] Delete All Items with clear() syntax: list.clear() >>> languages=['C','C#','Java','Python'] >>> languages.clear() >>> languages [] Find an Item's Offset by Value with index() Syntax: list.index('element') >>> languages=['C','C#','Java','Python'] >>> languages.index('C') 0 Test for Value with in Syntax: 'element' in list >>> languages=['C','C#','Java','Python'] >>> 'Python' in languages True >>> 'C++' in languages False Count Occurrences of Value with count() Syntax: list.count('element') >>> languages.count('C') 1 How to convert list to string ? Syntax: 'seperator'.join(list) >>> languages=['C','C#','Java','Python'] >>> ','.join(languages) 'C,C#,Java,Python' Reorder Items of the list Using python function: >>> languages=['Python','C#','Java','C'] >>> sorted(languages) ['C', 'C#', 'Java', 'Python'] >>> languages #original order will never changed ['Python','C#','Java','C'] Using list method: >>> languages=['Python','C#','Java','C'] >>> languages.sort() >>> languages ['C', 'C#', 'Java', 'Python'] >>> languages=['Python','C#','Java','C'] >>> languages.sort(reverse=True) # sort reverse order >>> languages ['Python', 'Java', 'C#', 'C'] Get Length with len() Syntax: len(list) >>> len(languages) 4 Assign with = When you assign one list to more than one variable, changing the list in one place also changes it in the other. >>> a=[1,2,3,4] >>> id(a) 2109612147720 >>> b=a >>> id(b) 2109612147720 >>> a[0]='hello' >>> a ['hello', 2, 3, 4] >>> b ['hello', 2, 3, 4] >>> b[1]='hi' >>> a ['hello', 'hi', 3, 4] Compare lists: >>> a = [1,2,3] >>> b = [7,8,9] >>> a == b False >>> b>a True Iterate with for and in >>> languages=['C','C#','JAVA','PYTHON'] >>> for i in languages: ... print(i) c c# Java Python break ends the for loop and continue steps to next iteration >>> languages=['C','C#','JAVA','PYTHON','HTML','GO'] >>> for i in languages: ... if i.lower()=='html': ... print('HTML is not a programming language like others') ... break ... else: ... print(i) C C# JAVA PYTHON HTML is not a programming language like others We can use the optional else if the for Completed without a break >>> languages=['C','C#','JAVA','PYTHON','GO'] >>> for language in languages: ... if language.lower()=='html': ... print('HTML is not a programming language like others') ... break ... else: ... print(language) ... else: ... print('There are no non-programming languages') C C# JAVA PYTHON GO There are no non-programming languages If the initial for never ran, control goes to the else also: >>> cheeses=[] ... for cheese in cheeses: ... print(cheese) ... break ... else: ... print('There is no cheese') There is no cheese cheeses list was empty in this example, for cheese in cheeses never completed a single loop and its break statement was never executed. >>> days=['Monday','Tuesday','Wednesday'] >>> fruits=['banana','orange','peach'] >>> drinks=['coffee','tea','ice tea'] >>> desserts=['double ka meeta','ice cream','jamoon','pudding'] >>> for day, fruit, drink, dessert in zip(days, fruits, drinks, desserts): ... print(day, \": drink\", drink, \"- eat\",fruit, \"- enjoy\", dessert) Monday : drink coffee - eat banana - enjoy double ka meeta Tuesday : drink tea - eat orange - enjoy ice cream Wednesday : drink ice tea - eat peach - enjoy jamoon zip() stops when the shortest sequence is done. List of lists >>> small_birds=['hamming_bird','finch'] >>> extinct_birds=['dodo','passenger pigeon','Norwegian Blue'] >>> carol_birds=[3,'French hens',2,'turtledoves'] >>> all_birds=[small_birds,extinct_birds,carol_birds] >>> all_birds [['hamming_bird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], [3, 'French hens', 2, 'turtledoves']] >>> all_birds[0] ['hamming_bird', 'finch'] >>> all_birds[1] ['dodo', 'passenger pigeon', 'Norwegian Blue'] >>> all_birds[1][0] 'dodo' Go to Top Learning Check Home Tuples Tuple is non mutable type Tuple will be represented with (). >>> empty_tuple = () >>> empty_tuple () >>> type(empty_tuple) tuple To make a tuple with one or more elements, follow each element with a comma. This works for one-element tuples >>> one_color = 'Green', >>> one_color ('Green',) >>> one_color=('Green',) >>> one_color ('Green',) >>> multi_color='Green','Red','White' >>> multi_color ('Green', 'Red', 'White') Tuple let you assign multiple variables at once: >>> a = list(multi_color) >>> tuple(a) ('Green', 'Red', 'White') >>> a,b,c = multi_color >>> a Green >>> b Red >>> c White This is called tuple unpacking You can use tuples to exchange values in one statement without using a temporary variables. >>> password = 'confidential' >>> icecream = 'choclate' >>> password, icecream = icecream, password >>> password choclate >>> icecream confidential >>> a = password,icecream >>> a ('choclate', 'confidential') Create tuple with the tuple() >>> numbers=[1,3,5,7] >>> tuple(numbers) (1, 3, 5, 7) Combine Tuples by Using + This is similar to combining strings >>> ('Groucho',)+('Chico','harpo') ('Groucho', 'Chico', 'harpo') Duplicate items with * This is like repeated use of +: >>> ('yada',)*3 ('yada','yada','yada') Compare tuples This works much like list comparisions >>> a=(7,2) >>> b=(7,2,9) >>> a==b False >>> a<=b True Iterate with for and in >>> items = ('good','bad','ugly') >>> for word in items: ... print(word) ... good bad ugly Modify tuple >>> t1=('Fee','Fie','Foe') >>> id(t1) 2109612850296 >>> t2='top', >>> t1+=t2 >>> t1 ('Fee', 'Fie', 'Foe', 'top') >>> id(t1) 2109616422168 >>> id(t2) 2109612420936 count the elements in touple >>> t1 = ('Fee', 'Fie', 'Foe', 'top') >>> t1.count('Fee') 1 >>> t1.count('Free') 0 Get the index of particular value in the tuple. >>> t1 = ('Fee', 'Fie', 'Foe', 'top') >>> t1.index('top') 3 >>> t1.index('Free') # exception will araise Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: tuple.index(x): x not in tuple Got to top Home Sets Here is the above picture: A = {1,2,3,4,5} B = {1,2,6,7,8} A \u222a B = {1,2,3,4,5,6,7,8} A \u2229 B = {1,2} A - B = {3,4,5} A set is like a dictionarywith its values thrown away,leaving only the keys.As with a dictionary, each key must be unique. create with set() >>> empty_set = set() >>> empty_set set() Convert with set() You can create a set from a list, string, tuple, or dictionary, discarding any duplicate values. >>> set('letters') {'s', 'e', 'l', 't', 'r'} >>> set( ['Java', 'C', 'C#', 'Python'] ) {'C', 'C#', 'Java', 'Python'} >>> set(('a','b','c','d')) {'a', 'b', 'c', 'd'} >>> set( {'apple': 'red', 'orange': 'orange', 'cherry': 'red'} ) {'apple', 'cherry', 'orange'} Get Length with len() >>> lang=set(['c','c++','Java','Python']) >>> len(lang) 4 Add an item with add() >>> s = set((1,2,3,4)) >>> s.add(4) >>> s {1, 2, 3, 4} Delete an item with remove() >>> A = {1,2,3,4,5} >>> A.remove(1) >>> A {2,3,4,5} >>> A.remove(5) >>> A {2,3,4} >>> A.remove(99) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 99 Iterate with for and in >>> furniture = set(('sofa', 'ottoman', 'table')) >>> for comp in furniture: ... print(comp) ... table sofa ottoman Combinations and operators >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.union(B) {1, 2, 3, 4, 5, 6, 7, 8} >>> A|B {1, 2, 3, 4, 5, 6, 7, 8} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.intersection(B) {1,2} >>> A&B {1,2} intersection_update() will update the A with the result >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.intersection_update(B) >>> A {1,2} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A-B {3,4,5} >>> A.difference(B) {3,4,5} difference_update() will update the set A with the results. >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.difference_update(B) >>> A {3,4,5} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.symmetric_difference(B) {3, 4, 5, 6, 7, 8} >>> A^B {3, 4, 5, 6, 7, 8} symmetric_difference_update() will update the set with the result. >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.symmetric_difference_update(B) >>> A {3, 4, 5, 6, 7, 8} A \u2282 B >>> A = {1,2,4} >>> B = {1,2,3,4,5} >>> A.issubset(B) True >>> A<=B True A \u2283 B >>> A = {1,2,4} >>> B = {1,2,3,4,5} >>> B.issuperset(A) True >>> B>=A True Disjoint set: >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> C = {9,10} >>> A.isdisjoint(B) False >>> A.isdisjoint(C) True Delete all elements in the set using clear() Syntax: set.clear() >>> s = {'C'.'C++','JAVA'} >>> s.clear() >>> s set() Copy a set using copy method: syntax: another_set = set.copy() >>> s= {'C'.'C++','JAVA'} >>> ss = s.copy() >>> ss {'Java', 'C++', 'C'} Remove the member of a set using discard() syntax: set.discard(member) >>> A = {1,2,3,4,5} >>> A.discard(4) >>> A {1,2,3,5} >>> A.discard(99) #remove member which is not in the set >>> A # will not get any exception {1,3,5} Delete an element using pop() pop() by default delete first element in the set. >>> A = {1,2,3,4,5} >>> A.pop() 1 >>> A.pop() 2 >>> A {3,4,5} >>> A.pop(2) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: pop() takes no arguments (1 given) Update: combine two sets into one using update() syntax: set1.update(set2) >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.update(B) {1, 2, 3, 4, 5, 6, 7, 8} Got to top Home Dictionaries A dictionary is similar to a list,but the order of items doesn\u2019t matter, and they aren\u2019t selected by an offset such as 0 or 1. Instead,you specify a unique key to associate with each value. This key is often a string,but it can actually be any of Python\u2019s immutable types In other languages, dictionaries might be called associative arrays, hashes, or hashmaps. Dictionaries are mutable,so you can add, delete, and change their key-value elements. Create dictionary: To create a dictionary, you place curly brackets({}) around comma-separated key : value pairs.The simplest dictionary is an empty one,containing no keys or values at all: >>> empty_dict = {} >>> empty_dict {} >>> type(empty_dict) dict >>> colors={'Black':'#000000', 'White':'#FFFFFF', 'Red':'#FF0000', 'Green':'#00FF00', 'Blue':'#0000FF', 'Yellow':'#FFFF00', 'Magenta':'#FF00FF', 'Cyan':'#00FFFF'} >>> colors['Yellow'] '#FFFF00' >>> colors['Orange'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'Orange' >>> colors['Green'] '#00FF00' >>> days={'MON':'Monday','TUE':'Tuesday','WED':'Wednesday','THU':'Thuresday','FRI':'Friday','SAT':'Saturday','SUN':'Sunday'} >>> days {'MON': 'Monday', 'TUE': 'Tuesday', 'WED': 'Wednesday', 'THU': 'Thuresday', 'FRI': 'Friday', 'SAT': 'Saturday', 'SUN': 'Sunday'} Create dictionary using dict() >>> details=dict(Department='CSE',Year='IInd',BatchYear=2018) >>> details[Department] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'Department' is not defined >>> details['Department'] 'CSE' >>> type(details) <class 'dict'> One limitation of the second way is that the argument namesneed to be legal variable names (no spaces, no reserved words) >>> details=dict(Department='CSE',Year='IInd',BatchYear=2018, def='Computers') File \"<stdin>\", line 1 details=dict(Department='CSE',Year='IInd',BatchYear=2018, def='Computers') ^ SyntaxError: invalid syntax Converting with dict() You can also use the dict() function to convert two-valuesequences into a dictionary. >>> lol=[['a','b'],['c','d'],['e','f']] >>> dict(lol) {'a': 'b', 'c': 'd', 'e': 'f'} A List of two-item tuples: >>> lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] >>> dict(lot) {'a': 'b', 'c': 'd', 'e': 'f'} A tuple of two-item lists: >>> tol = ( ['a', 'b'], ['c', 'd'], ['e', 'f'] ) >>> dict(tol) {'a': 'b', 'c': 'd', 'e': 'f'} >>> los = [ 'ab', 'cd', 'ef' ] >>> dict(los) {'a': 'b', 'c': 'd', 'e': 'f'} >>> tos = ( 'ab', 'cd', 'ef' ) >>> dict(tos) {'a': 'b', 'c': 'd', 'e': 'f'} A tuple of two-character strings: >>> tos = ( 'ab', 'cd', 'ef' ) >>> dict(tos) {'a': 'b', 'c': 'd', 'e': 'f'} Add or Change an Item by [key]: Adding an item in the dictionary is by assigning value to the key. If the key was already present in the dictionary,the existing value is replaced by the new one. If the key is new,it\u2019s added to the dictionary with its value. >>> movies={'action':'star wars','comedy':'friends', 'sci-fi':'The Mandalorian','thriller':'Joker'} >>> movies['anim']='frozen-II' >>> movies {'action': 'star wars', 'comedy': 'friends', 'sci-fi': 'The Mandalorian', 'thriller': 'Joker', 'anim': 'frozen-II'} ``` - Change value by using key ```python >>> movies['anim']='toy story4' >>> movies {'action': 'star wars', 'comedy': 'friends', 'sci-fi': 'The Mandalorian', 'thriller': 'Joker', 'anim': 'toy story4'} ``` Get an item with [key] or get() ```python >>> movies['action'] 'star wars' If the key is not present in dictionary. It will throw an exception >>> movies['horror'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'horror' Alternative way to check whether key is in the dictionary or not. >>> 'horror' in movies False >>> movies.get('horror') >>> movies.get('action') 'star wars' >>> movies.get('horror','not yet added') 'not yet added' Get all keys with keys() >>> movies.keys() dict_keys(['action', 'comedy', 'sci-fi', 'thriller', 'anim']) Get all values with values() >>> movies.values() dict_values(['star wars', 'friends', 'The Mandalorian', 'Joker', 'ricky and morty']) Get all key-value pairs with items() >>> movies.items() dict_items([('action', 'star wars'), ('comedy', 'friends'), ('sci-fi', 'The Mandalorian'), ('thriller', 'Joker'), ('anim', 'ricky and morty')]) Get Length with len() >>> len(movies) 5 Combine dictionaries with { a, b} >>> first = {'a': 'agony', 'b': 'bliss'} >>> second = {'b': 'bagels', 'c': 'candy'} >>> {**first, **second} {'a': 'agony', 'b': 'bagels', 'c': 'candy'} >>> third = {'d': 'donuts'} >>> {**first, **third, **second} {'a': 'agony', 'b': 'bagels', 'd': 'donuts', 'c': 'candy'} Combine Dictionaries with update() You can use the update() function tocopy the keys and values of one dictionary into another >>> first = {'a': 'agony', 'b': 'bliss'} >>> second = {'b': 'bagels', 'c': 'candy'} >>> first.update(second) >>> first {'a': 'agony', 'b': 'bagels', 'c': 'candy'} >>> first = {'a': 1, 'b': 2,'c':3,'d':4,'e':5} >>> second = {'b': 'platypus'} >>> first.update(second) >>> first {'a': 1, 'b': 'platypus', 'c': 3, 'd': 4, 'e': 5} Delete an Item by key with del >>> first = {'a': 'agony', 'b': 'bliss'} >>> del first['a'] >>> first {'b': 'bliss'} >>> del first['a'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'a' Get an Item by key and Delete It with pop() This combines get() and del.If you give pop() a key and it exists in the dictionary,it returns the matching value and deletes the key-value pair. If it doesn\u2019t exist, it raises an exception >>> first = {'a': 'agony', 'b': 'bliss'} >>> first.pop('a') 'agony' >>> first.pop('a') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'a' >>> first.pop('a','nothing') 'nothing' Delete All Items with clear() To delete all keys and values from a dictionary,use clear() or just reassign an empty dictionary({}) to the name >>> A={'a': 1, 'b': 'platypus', 'c': 3, 'd': 4, 'e': 5} >>> A.clear() >>> A {} Test for a key with in >>> first = {'a': 1, 'b': 2,'c':3,'d':4,'e':5} >>> 'a' in first True >>> 'f' in first False Compare dictionaries Dictionaries can be compared with the simple comparison operators == and != >>> a = {1:1, 2:2, 3:3} >>> b = {3:3, 1:1, 2:2} >>> a == b True >>> a<b Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '<' not supported between instances of 'dict' and 'dict' Python compares the keys and values one by one. The order in which they were originally created doesn\u2019t matter >>> a = {1: [1, 2], 2: [1], 3:[1]} >>> b = {1: [1, 1], 2: [1], 3:[1]} >>> a!=b True Iterate with for and in >>> signals = {'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'} >>> for i in signals: ... print(i) ... green yellow red >>> for i in signals.keys(): ... print(i) ... green yellow red >>> for i in signals.values(): ... print(i) ... go go faster smile for the camera >>> for item in signals.items(): ... print(item) ... ('green', 'go') ('yellow', 'go faster') ('red', 'smile for the camera') >>> for key, value in signals.items(): ... print(key,'-',value) ... green - go yellow - go faster red - smile for the camera Create a dictionary from any iterable data type. >>> a = ['one','two','three','four'] >>> dict.fromkeys(a) {'one': None, 'two': None, 'three': None, 'four': None} popitem() : Remove and return a (key, value) pair as a 2-touple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. >>> a = {1: [1, 1], 2: [1], 3: [1]} >>> a.popitem() (3, [1]) >>> a.popitem(1) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: popitem() takes no arguments (1 given) setdefault(): Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. >>> a = {1: [1, 1], 2: [1], 3: [1]} >>> a.setdefault(4) >>> a a = {1: [1, 1], 2: [1], 3: [1], 4: None} >>> a.setdefault(1) [1,1] Got to top Home","title":"Collections"},{"location":"collections/#collections","text":"","title":"Collections"},{"location":"collections/#strings-str","text":"Str is the short form of string Str data type is immutable i.e once you declare it, you cannot able to modify it. Syntax: >>>\"this is string\" 'this is string' >>>'this is also a string' 'this is also a string' >>>\"This is not way of declering the string' File \"<stdin>\", line 1 \"This is not way of declering the string' ^ SyntaxError: EOL while scanning string literal >>>'This is also not way of declering the string\" File \"<stdin>\", line 1 'This is also not way of declering the string\" ^ SyntaxError: EOL while scanning string literal You can check the data type of the string >>>a = \"paly with python\" >>>type(a) <class 'str'> String with new lines: Multi line strings: spread the literal across multipule lines. >>>\"\"\" This is ... multi line string ... this is end\"\"\" 'This is\\nmulti line string\\nthis is end' >>> poem = \"\"\"Just like moons and like suns, ... With the certainity of tides, ... Just like hopes springing high, ... Still I'll raise.\"\"\" >>> poem 'Just like moons and like suns,\\nWith the certainity of tides,\\nJust like hopes springing high,\\nStill I'll raise.' >>> print(poem) Just like moons and like suns, With the certainity of tides, Just like hopes springing high, Still I'll raise. Escape sequences : Embed escape sequences in a single-line literal Python lets you escape the meaning of some characters with in strings to achieve effects that would otherwise be difficult to express.By preceding a character with a backslash (), you give it a special meaning.The most common escape sequence is \\n,which means to begin a new line. >>> 'This is\\nmulti line string\\nthis is end' 'This is\\nmulti line string\\nthis is end' >>> a = 'You are not your parents\\nYou are not your class\\nYou are not the clothes you wear\\nYou are not the size of your friend circle\\nYour sum of your words. choices and actions.' >>> a 'You are not your parents\\nYou are not your class\\nYou are not the clothes you wear\\nYou are not the size of your friend circle\\nYour sum of your words. choices and actions.' >>> print(a) You are not your parents You are not your class You are not the clothes you wear You are not the size of your friend circle Your sum of your words. choices and actions. More escape sequences: >>> palindrome = 'A man,\\nA plan,\\nA canal:\\nPanama.' >>> print(palindrome) A man, A plan, A canal: Panama. >>> print('\\tabc') abc >>> print('a\\tbc') a bc >>> print('ab\\tc') ab c >>> testimony = \"\\\"I did nothing!\\\" he said. \\\"Or that other thing.\\\"\" >>> print(testimony) \"I did nothing!\" he said. \"Or that other thing.\" >>> fact = \"The world's largest rubber duck was 54'2\\\" by 65'7\\\" by 105'\" >>> print(fact) The world's largest rubber duck was 54'2\" by 65'7\" by 105' >>> speech = 'The backslash (\\\\) can be printed using like this.' >>> print(speech) The backslash (\\) can be printed using like this. Combining by using + we can combine literal strings or string variables using the + operator. >>> \"good \"+\"morning\" 'good morning' >>> name = \"Joe\" >>> branch = \" computer science and engineering\" >>> print(name+branch) Joe computer science and engineering >>> a = 'Duck.' >>> b = a >>> c = 'Grey Duck!' >>> a+b+c 'Duck.Duck.Grey Duck!' Duplicate with * We use the * operator to duplicate a string. >>> \"hi\"*3 'hihihi' >>> \"hello \"*3 'hello hello hello' >>> a = 'Na ' * 4 + '\\n' >>> b = 'Hey ' * 3 + '\\n' >>> end = 'Goodbye.' >>> print(start + start + middle + end) Na Na Na Na Na Na Na Na Hey Hey Hey Goodbye. Notice that the * has higher precedence than +, so the string is duplicated before the line feed is tacked on. Get characters with [] To get a single character from a string, specify its offset inside square brackets after the string\u2019s name. The first (leftmost) offset is 0, the next is 1, and so on. >>> letters = 'abcdefghijklmnopqrstuvwxyz' >>> letters[0] a >>> letters[25] z Get a substring with a slice syntax: [start_offset:end_offset:step(optional)] >>> letters[1:11] 'bcdefghijk' >>> letters[1:20:2] 'bdfhjlnprt' >>> letters[::5] 'afkpuz' >>> letters[21] 'v' Get Length with len() The len() function counts characters in a string: Syntax: len(string) >>> letters = 'abcdefghijklmnopqrstuvwxyz' >>> len(letters) 26 >>> empty = \"\" >>> len(empty) 0 spilt with split() You can use the built-in string split() function to break a string into a list of smaller strings based on some separator. syntax: string.split('seperator') >>> tasks = 'get gloves,get mask,give cat vitamins,call ambulance' >>> tasks.split(',') ['get gloves', 'get mask', 'give cat vitamins', 'call ambulance'] >>> tasks.split() ['get', 'gloves,get', 'mask,give', 'cat', 'vitamins,call', 'ambulance'] combine by using join() syntax: seperator.join(list) >>> crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster'] >>> crypto_string = ', '.join(crypto_list) >>> print(crypto_string) Yeti, Bigfoot, Loch Ness Monster Substitute by Using replace() You use replace() for simple substring substitution.Give it the old substring, the new one,and how many instances of the old substring to replace. It returns the changed string but does notmodify the original string.If you omit this final count argument, it replaces all instances. Syntax: string.replace(old_substring, new_substring, count(optional)) >>> setup = \"a duck goes into a bar...\" >>> setup.replace('duck', 'marmoset') >>> setup.replace('duck', 'marmoset') 'a marmoset goes into a bar...' >>> setup 'a duck goes into a bar...' Strip with strip() The strip() functions shown here assume that you want to get rid ofwhitespace characters (' ', '\\t', '\\n')if you don\u2019t give them an argument.strip() str. strip() strips both ends, lstrip() only from the left, and rstrip() only from the right. Syntax : string.strip() >>> world = \" earth \" >>> world.strip() 'earth' >>> world.strip(' ') 'earth' >>> world.lstrip() 'earth ' >>> world.rstrip() ' earth' If the character were not there, nothing happens: >>> world.strip('!') ' earth ' Besides no argument (meaning whitespace characters) or a single character, you can also tell strip() to remove any character in a multicharacter string: >>> blurt = \"What the...!!?\" >>> blurt.strip('.?!') 'What the' Search and Select >>> poem = '''All that doth flow we cannot liquid name ... Or else would fire and water be the same; ... But that is liquid which is moist and wet ... Fire that property can never get .... Then 'tis not cold that doth the fire put out ... But 'tis the wet that makes it die, no doubt.''' >>> poem[:13] 'All that doth' >>> len(poem) 254 >>> poem.startswith('All') True >>> poem.endswith('That\\'s all, folks!') False Let\u2019s find the offset of the first occurrenceof the word the in the poem: >>> word='the' >>> poem.find(word) 73 >>> poem.index(word) 73 And the offset of the last the: >>> word = 'the' >>> poem.rfind(word) 218 >>> poem.rindex(word) 218 How many times does the three-letter sequence 'the' occur? >>> poem.count(word) 3 Are all of the characters in the poem either letters or numbers? >>> poem.isalnum() False Cases: >>> setup = 'a duck goes into a bar...' >>> setup.strip('.') 'a duck goes into a bar' Capitalize the first word: >>> setup.capitalize() 'A duck goes into a bar...' Capitalize all the words: >>> setup.title() 'A Duck Goes Into A Bar...' Convert all characters to uppercase: >>> setup.upper() 'A DUCK GOES INTO A BAR...' Convert all characters to lowercase: >>> setup.lower() 'a duck goes into a bar...' Swap uppercase and lowercase: >>> setup.swapcase() 'A DUCK GOES INTO A BAR...' >>> setup 'a duck goes into a bar...' Formatting : %s string %d decimal integer %x hex integer %o octal integer %f decimal float %e exponential float %g decimal or exponential float You can use a %s for any data type, and Python will format it as a string with no extra spaces. >>> '%s' % 42 '42' >>> '%d' % 42 '42' >>> '%x' % 42 '2a' >>> '%o' % 42 '52' An integer and a literal %: >>> '%d%%' % 100 '100%' Let's try some string and integer interpolation: >>> actor = 'Richard Gere' >>> cat = 'Chester' >>> weight = 28 >>> \"My friend's favorite actor is %s\" % actor \"My friend's favorite actor is Richard Gere\" >>> \"Our cat %s weighs %d pounds\" % (cat, weight) 'Our cat Chester weighs 28 pounds' some more examples >>> thing = 'woodchuck' >>> '%s' % thing 'woodchuck' >>> '%12s' % thing ' woodchuck' >>> '%+12s' % thing ' woodchuck' >>> '%-12s' % thing 'woodchuck ' >>> '%.3s' % thing 'woo' >>> '%12.3s' % thing ' woo' >>> '%-12.3s' % thing 'woo ' one more with feeling >>> thing = 98.6 >>> '%f' % thing '98.600000' >>> '%12f' % thing ' 98.600000' >>> '%6f' % thing '98.600000' >>> '%+12f' % thing ' +98.600000' >>> '%-12f' % thing '98.600000 ' >>> '%.3f' % thing '98.600' >>> '%12.3f' % thing ' 98.600' >>> '%-12.3f' % thing '98.600 ' New style:{} and format() \u201cNew style\u201d formatting has the form format_string.format(data). >>> thing = 'woodchuck' >>> '{}'.format(thing) 'woodchuck' The arguments to the format() function need to be in the order as the {} placeholders in the format string: >>> thing = 'woodchuck' >>> place = 'lake' >>> 'The {} is in the {}.'.format(thing, place) 'The woodchuck is in the lake.' With new-style formatting, you can also specify the arguments by position like this: >>> 'The {1} is in the {0}.'.format(place, thing) 'The woodchuck is in the lake.' The value 0 referred to the first argument, place, and 1 referred to thing. The arguments to format() can also be named arguments >>> 'The {thing} is in the {place}'.format(thing='duck', place='bathtub') 'The duck is in the bathtub' or a dictionary: >>> d = {'thing': 'duck', 'place': 'bathtub'} >>> 'The {0[thing]} is in the {0[place]}.'.format(d) 'The duck is in the bathtub.' More Examples: >>> thing = 'wraith' >>> place = 'window' >>> 'The {} is at the {}'.format(thing, place) 'The wraith is at the window' >>> 'The {:10s} is at the {:10s}'.format(thing.upper(), place) 'The WRAITH is at the window ' >>> 'The {:<10s} is at the {:<10s}'.format(thing, place) 'The wraith is at the window ' >>> 'The {:^10s} is at the {:^10s}'.format(thing, place) 'The wraith is at the window ' >>> 'The {:>10s} is at the {:>10s}'.format(thing, place) 'The wraith is at the window' >>> 'The {:!^10s} is at the {:!^10s}'.format(thing, place) 'The !!wraith!! is at the !!window!!' Newest Style: f-strings f-strings appeared in Python 3.6, and are now the recommended way of formatting strings. To make an f-string: Type the letter f or F directly before the initial quote. Include variable names or expressions within curly brackets ({}) to get their values into the string. >>> thing = 'wereduck' >>> place = 'werepond' >>> f'The {thing} is in the {place}' 'The wereduck is in the werepond' >>> f'The {thing.capitalize()} is in the {place.rjust(20)}' 'The Wereduck is in the werepond' >>> f'The {thing:>20} is in the {place:.^20}' 'The wereduck is in the ......werepond......' Starting in Python 3.8, f-strings gain a new shortcut that\u2019s helpful when you want to print variable names as well as their values. >>> f'{thing =}, {place =}' \"thing ='wereduck', place ='werepond'\" >>> f'{thing[-4:] =}, {place.title() =}' \"thing[-4:] ='duck', place.title() ='Werepond'\" >>> f'{thing = :>4.4}' 'thing = were' for more details: python documentation These examples are borrowed from the \"Introducing Python\" 2nd Edition by Bill Lubanovic, O'Reilly media inc.,2019 Think Python, Second Edition, Allen B. Downey, 2016, O'Reilly Go to top Learning check Home","title":"Strings: str"},{"location":"collections/#bytes","text":"Data type for sequence of bytes Raw binary data Fixed width single byte encoding >>> b'byte data' b'byte data' >>> d= b'some bytes' >>> type(d) <class 'bytes'> >>> d.split() [b'some', b'bytes'] Converting between strings and bytes: >>> a = b'byte data' >>> a.decode() 'byte data' >>> b = 'hello python' >>> b.encode() b'hello python' Go to Top Home","title":"Bytes"},{"location":"collections/#lists","text":"sequence of objects Lists are Mutable Lists are declared with [] or list() Items are seperated with comma(,) Create empty list >>> myfirst_list = [] # one way of creating empty list >>> type(myfirst_list) <class 'list'> >>> mysecond_list = list() # another way of creating empty list >>> type(mysecond_list) <class 'list'> python list() converts string into list >>> list('python') ['p', 'y', 't', 'h', 'o', 'n'] Create a list from string split() >>> python_day='12/12/2019' >>> python_day.split('/') ['12', '12', '2019'] list.reverse() : To reverse the elements in the list >>> lang=['c','c++','java','python'] >>> lang.reverse() >>> lang ['python', 'java', 'c++', 'c'] Add an Item to the End with append() >>> lang=['c','c++','java','python'] >>> lang.append('R') >>> lang ['c', 'c++', 'java', 'python', 'R'] Add an Item by Offset with insert() syntax: insert(index, word) Examples: >>> lang=['c', 'c++', 'java', 'python', 'R'] >>> lang.insert(2,'scala') >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R'] Duplicate All Items with * syntax: ['string']*value Examples: >>> ['python']*3 ['python', 'python', 'python'] >>> ['python','java']*3 ['python', 'java', 'python', 'java', 'python', 'java'] Combine Lists by Using extend() or + >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R'] >>> markups=['html','xml'] >>> lang.extend(markups) >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml'] >>> server_scripting=['PHP','ASP','JSP'] >>> lang=lang+server_scripting >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP'] >>> lang+=server_scripting >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP'] >>> client_scripting=['javascript','actionscript'] >>> lang.append(client_scripting) >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] Change an Item by [offset] >>> lang ['c', 'c++', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] >>> lang[1]='c#' >>> lang ['c', 'c#', 'scala', 'java', 'python', 'R', 'html', 'xml', 'PHP', 'ASP', 'JSP', 'PHP', 'ASP', 'JSP', ['javascript', 'actionscript']] ``` Change an item with slice ```python >>> numbers=[1,2,3,4] >>> numbers[1:3]=[8,9] >>> numbers [1, 8, 9, 4] Delete an Item by Offset with del syntax: del list[offset] Examples: >>> languages=['C','C#','Java','Python'] >>> del languages[-1] >>> languages ['C', 'C#', 'Java'] >>> del languages[0:2] >>> languages ['Java'] Delete an Item by Value with remove() syntax: list.remove('element') Examples: >>> languages=['C','C#','Java','Python'] >>> languages.remove('C#') Get an Item Offset and Delete It with pop() syntax: list.pop(offset) >>> languages=['C','C#','Java','Python'] >>> languages.pop() 'Python' >>> languages.pop(1) 'C#' >>> languages ['C', 'Java'] Delete All Items with clear() syntax: list.clear() >>> languages=['C','C#','Java','Python'] >>> languages.clear() >>> languages [] Find an Item's Offset by Value with index() Syntax: list.index('element') >>> languages=['C','C#','Java','Python'] >>> languages.index('C') 0 Test for Value with in Syntax: 'element' in list >>> languages=['C','C#','Java','Python'] >>> 'Python' in languages True >>> 'C++' in languages False Count Occurrences of Value with count() Syntax: list.count('element') >>> languages.count('C') 1 How to convert list to string ? Syntax: 'seperator'.join(list) >>> languages=['C','C#','Java','Python'] >>> ','.join(languages) 'C,C#,Java,Python' Reorder Items of the list Using python function: >>> languages=['Python','C#','Java','C'] >>> sorted(languages) ['C', 'C#', 'Java', 'Python'] >>> languages #original order will never changed ['Python','C#','Java','C'] Using list method: >>> languages=['Python','C#','Java','C'] >>> languages.sort() >>> languages ['C', 'C#', 'Java', 'Python'] >>> languages=['Python','C#','Java','C'] >>> languages.sort(reverse=True) # sort reverse order >>> languages ['Python', 'Java', 'C#', 'C'] Get Length with len() Syntax: len(list) >>> len(languages) 4 Assign with = When you assign one list to more than one variable, changing the list in one place also changes it in the other. >>> a=[1,2,3,4] >>> id(a) 2109612147720 >>> b=a >>> id(b) 2109612147720 >>> a[0]='hello' >>> a ['hello', 2, 3, 4] >>> b ['hello', 2, 3, 4] >>> b[1]='hi' >>> a ['hello', 'hi', 3, 4] Compare lists: >>> a = [1,2,3] >>> b = [7,8,9] >>> a == b False >>> b>a True Iterate with for and in >>> languages=['C','C#','JAVA','PYTHON'] >>> for i in languages: ... print(i) c c# Java Python break ends the for loop and continue steps to next iteration >>> languages=['C','C#','JAVA','PYTHON','HTML','GO'] >>> for i in languages: ... if i.lower()=='html': ... print('HTML is not a programming language like others') ... break ... else: ... print(i) C C# JAVA PYTHON HTML is not a programming language like others We can use the optional else if the for Completed without a break >>> languages=['C','C#','JAVA','PYTHON','GO'] >>> for language in languages: ... if language.lower()=='html': ... print('HTML is not a programming language like others') ... break ... else: ... print(language) ... else: ... print('There are no non-programming languages') C C# JAVA PYTHON GO There are no non-programming languages If the initial for never ran, control goes to the else also: >>> cheeses=[] ... for cheese in cheeses: ... print(cheese) ... break ... else: ... print('There is no cheese') There is no cheese cheeses list was empty in this example, for cheese in cheeses never completed a single loop and its break statement was never executed. >>> days=['Monday','Tuesday','Wednesday'] >>> fruits=['banana','orange','peach'] >>> drinks=['coffee','tea','ice tea'] >>> desserts=['double ka meeta','ice cream','jamoon','pudding'] >>> for day, fruit, drink, dessert in zip(days, fruits, drinks, desserts): ... print(day, \": drink\", drink, \"- eat\",fruit, \"- enjoy\", dessert) Monday : drink coffee - eat banana - enjoy double ka meeta Tuesday : drink tea - eat orange - enjoy ice cream Wednesday : drink ice tea - eat peach - enjoy jamoon zip() stops when the shortest sequence is done. List of lists >>> small_birds=['hamming_bird','finch'] >>> extinct_birds=['dodo','passenger pigeon','Norwegian Blue'] >>> carol_birds=[3,'French hens',2,'turtledoves'] >>> all_birds=[small_birds,extinct_birds,carol_birds] >>> all_birds [['hamming_bird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], [3, 'French hens', 2, 'turtledoves']] >>> all_birds[0] ['hamming_bird', 'finch'] >>> all_birds[1] ['dodo', 'passenger pigeon', 'Norwegian Blue'] >>> all_birds[1][0] 'dodo' Go to Top Learning Check Home","title":"Lists"},{"location":"collections/#tuples","text":"Tuple is non mutable type Tuple will be represented with (). >>> empty_tuple = () >>> empty_tuple () >>> type(empty_tuple) tuple To make a tuple with one or more elements, follow each element with a comma. This works for one-element tuples >>> one_color = 'Green', >>> one_color ('Green',) >>> one_color=('Green',) >>> one_color ('Green',) >>> multi_color='Green','Red','White' >>> multi_color ('Green', 'Red', 'White') Tuple let you assign multiple variables at once: >>> a = list(multi_color) >>> tuple(a) ('Green', 'Red', 'White') >>> a,b,c = multi_color >>> a Green >>> b Red >>> c White This is called tuple unpacking You can use tuples to exchange values in one statement without using a temporary variables. >>> password = 'confidential' >>> icecream = 'choclate' >>> password, icecream = icecream, password >>> password choclate >>> icecream confidential >>> a = password,icecream >>> a ('choclate', 'confidential') Create tuple with the tuple() >>> numbers=[1,3,5,7] >>> tuple(numbers) (1, 3, 5, 7) Combine Tuples by Using + This is similar to combining strings >>> ('Groucho',)+('Chico','harpo') ('Groucho', 'Chico', 'harpo') Duplicate items with * This is like repeated use of +: >>> ('yada',)*3 ('yada','yada','yada') Compare tuples This works much like list comparisions >>> a=(7,2) >>> b=(7,2,9) >>> a==b False >>> a<=b True Iterate with for and in >>> items = ('good','bad','ugly') >>> for word in items: ... print(word) ... good bad ugly Modify tuple >>> t1=('Fee','Fie','Foe') >>> id(t1) 2109612850296 >>> t2='top', >>> t1+=t2 >>> t1 ('Fee', 'Fie', 'Foe', 'top') >>> id(t1) 2109616422168 >>> id(t2) 2109612420936 count the elements in touple >>> t1 = ('Fee', 'Fie', 'Foe', 'top') >>> t1.count('Fee') 1 >>> t1.count('Free') 0 Get the index of particular value in the tuple. >>> t1 = ('Fee', 'Fie', 'Foe', 'top') >>> t1.index('top') 3 >>> t1.index('Free') # exception will araise Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: tuple.index(x): x not in tuple Got to top Home","title":"Tuples"},{"location":"collections/#sets","text":"Here is the above picture: A = {1,2,3,4,5} B = {1,2,6,7,8} A \u222a B = {1,2,3,4,5,6,7,8} A \u2229 B = {1,2} A - B = {3,4,5} A set is like a dictionarywith its values thrown away,leaving only the keys.As with a dictionary, each key must be unique. create with set() >>> empty_set = set() >>> empty_set set() Convert with set() You can create a set from a list, string, tuple, or dictionary, discarding any duplicate values. >>> set('letters') {'s', 'e', 'l', 't', 'r'} >>> set( ['Java', 'C', 'C#', 'Python'] ) {'C', 'C#', 'Java', 'Python'} >>> set(('a','b','c','d')) {'a', 'b', 'c', 'd'} >>> set( {'apple': 'red', 'orange': 'orange', 'cherry': 'red'} ) {'apple', 'cherry', 'orange'} Get Length with len() >>> lang=set(['c','c++','Java','Python']) >>> len(lang) 4 Add an item with add() >>> s = set((1,2,3,4)) >>> s.add(4) >>> s {1, 2, 3, 4} Delete an item with remove() >>> A = {1,2,3,4,5} >>> A.remove(1) >>> A {2,3,4,5} >>> A.remove(5) >>> A {2,3,4} >>> A.remove(99) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 99 Iterate with for and in >>> furniture = set(('sofa', 'ottoman', 'table')) >>> for comp in furniture: ... print(comp) ... table sofa ottoman Combinations and operators >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.union(B) {1, 2, 3, 4, 5, 6, 7, 8} >>> A|B {1, 2, 3, 4, 5, 6, 7, 8} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.intersection(B) {1,2} >>> A&B {1,2} intersection_update() will update the A with the result >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.intersection_update(B) >>> A {1,2} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A-B {3,4,5} >>> A.difference(B) {3,4,5} difference_update() will update the set A with the results. >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.difference_update(B) >>> A {3,4,5} >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.symmetric_difference(B) {3, 4, 5, 6, 7, 8} >>> A^B {3, 4, 5, 6, 7, 8} symmetric_difference_update() will update the set with the result. >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.symmetric_difference_update(B) >>> A {3, 4, 5, 6, 7, 8} A \u2282 B >>> A = {1,2,4} >>> B = {1,2,3,4,5} >>> A.issubset(B) True >>> A<=B True A \u2283 B >>> A = {1,2,4} >>> B = {1,2,3,4,5} >>> B.issuperset(A) True >>> B>=A True Disjoint set: >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> C = {9,10} >>> A.isdisjoint(B) False >>> A.isdisjoint(C) True Delete all elements in the set using clear() Syntax: set.clear() >>> s = {'C'.'C++','JAVA'} >>> s.clear() >>> s set() Copy a set using copy method: syntax: another_set = set.copy() >>> s= {'C'.'C++','JAVA'} >>> ss = s.copy() >>> ss {'Java', 'C++', 'C'} Remove the member of a set using discard() syntax: set.discard(member) >>> A = {1,2,3,4,5} >>> A.discard(4) >>> A {1,2,3,5} >>> A.discard(99) #remove member which is not in the set >>> A # will not get any exception {1,3,5} Delete an element using pop() pop() by default delete first element in the set. >>> A = {1,2,3,4,5} >>> A.pop() 1 >>> A.pop() 2 >>> A {3,4,5} >>> A.pop(2) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: pop() takes no arguments (1 given) Update: combine two sets into one using update() syntax: set1.update(set2) >>> A = {1,2,3,4,5} >>> B = {1,2,6,7,8} >>> A.update(B) {1, 2, 3, 4, 5, 6, 7, 8} Got to top Home","title":"Sets"},{"location":"collections/#dictionaries","text":"A dictionary is similar to a list,but the order of items doesn\u2019t matter, and they aren\u2019t selected by an offset such as 0 or 1. Instead,you specify a unique key to associate with each value. This key is often a string,but it can actually be any of Python\u2019s immutable types In other languages, dictionaries might be called associative arrays, hashes, or hashmaps. Dictionaries are mutable,so you can add, delete, and change their key-value elements. Create dictionary: To create a dictionary, you place curly brackets({}) around comma-separated key : value pairs.The simplest dictionary is an empty one,containing no keys or values at all: >>> empty_dict = {} >>> empty_dict {} >>> type(empty_dict) dict >>> colors={'Black':'#000000', 'White':'#FFFFFF', 'Red':'#FF0000', 'Green':'#00FF00', 'Blue':'#0000FF', 'Yellow':'#FFFF00', 'Magenta':'#FF00FF', 'Cyan':'#00FFFF'} >>> colors['Yellow'] '#FFFF00' >>> colors['Orange'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'Orange' >>> colors['Green'] '#00FF00' >>> days={'MON':'Monday','TUE':'Tuesday','WED':'Wednesday','THU':'Thuresday','FRI':'Friday','SAT':'Saturday','SUN':'Sunday'} >>> days {'MON': 'Monday', 'TUE': 'Tuesday', 'WED': 'Wednesday', 'THU': 'Thuresday', 'FRI': 'Friday', 'SAT': 'Saturday', 'SUN': 'Sunday'} Create dictionary using dict() >>> details=dict(Department='CSE',Year='IInd',BatchYear=2018) >>> details[Department] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'Department' is not defined >>> details['Department'] 'CSE' >>> type(details) <class 'dict'> One limitation of the second way is that the argument namesneed to be legal variable names (no spaces, no reserved words) >>> details=dict(Department='CSE',Year='IInd',BatchYear=2018, def='Computers') File \"<stdin>\", line 1 details=dict(Department='CSE',Year='IInd',BatchYear=2018, def='Computers') ^ SyntaxError: invalid syntax Converting with dict() You can also use the dict() function to convert two-valuesequences into a dictionary. >>> lol=[['a','b'],['c','d'],['e','f']] >>> dict(lol) {'a': 'b', 'c': 'd', 'e': 'f'} A List of two-item tuples: >>> lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] >>> dict(lot) {'a': 'b', 'c': 'd', 'e': 'f'} A tuple of two-item lists: >>> tol = ( ['a', 'b'], ['c', 'd'], ['e', 'f'] ) >>> dict(tol) {'a': 'b', 'c': 'd', 'e': 'f'} >>> los = [ 'ab', 'cd', 'ef' ] >>> dict(los) {'a': 'b', 'c': 'd', 'e': 'f'} >>> tos = ( 'ab', 'cd', 'ef' ) >>> dict(tos) {'a': 'b', 'c': 'd', 'e': 'f'} A tuple of two-character strings: >>> tos = ( 'ab', 'cd', 'ef' ) >>> dict(tos) {'a': 'b', 'c': 'd', 'e': 'f'} Add or Change an Item by [key]: Adding an item in the dictionary is by assigning value to the key. If the key was already present in the dictionary,the existing value is replaced by the new one. If the key is new,it\u2019s added to the dictionary with its value. >>> movies={'action':'star wars','comedy':'friends', 'sci-fi':'The Mandalorian','thriller':'Joker'} >>> movies['anim']='frozen-II' >>> movies {'action': 'star wars', 'comedy': 'friends', 'sci-fi': 'The Mandalorian', 'thriller': 'Joker', 'anim': 'frozen-II'} ``` - Change value by using key ```python >>> movies['anim']='toy story4' >>> movies {'action': 'star wars', 'comedy': 'friends', 'sci-fi': 'The Mandalorian', 'thriller': 'Joker', 'anim': 'toy story4'} ``` Get an item with [key] or get() ```python >>> movies['action'] 'star wars' If the key is not present in dictionary. It will throw an exception >>> movies['horror'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'horror' Alternative way to check whether key is in the dictionary or not. >>> 'horror' in movies False >>> movies.get('horror') >>> movies.get('action') 'star wars' >>> movies.get('horror','not yet added') 'not yet added' Get all keys with keys() >>> movies.keys() dict_keys(['action', 'comedy', 'sci-fi', 'thriller', 'anim']) Get all values with values() >>> movies.values() dict_values(['star wars', 'friends', 'The Mandalorian', 'Joker', 'ricky and morty']) Get all key-value pairs with items() >>> movies.items() dict_items([('action', 'star wars'), ('comedy', 'friends'), ('sci-fi', 'The Mandalorian'), ('thriller', 'Joker'), ('anim', 'ricky and morty')]) Get Length with len() >>> len(movies) 5 Combine dictionaries with { a, b} >>> first = {'a': 'agony', 'b': 'bliss'} >>> second = {'b': 'bagels', 'c': 'candy'} >>> {**first, **second} {'a': 'agony', 'b': 'bagels', 'c': 'candy'} >>> third = {'d': 'donuts'} >>> {**first, **third, **second} {'a': 'agony', 'b': 'bagels', 'd': 'donuts', 'c': 'candy'} Combine Dictionaries with update() You can use the update() function tocopy the keys and values of one dictionary into another >>> first = {'a': 'agony', 'b': 'bliss'} >>> second = {'b': 'bagels', 'c': 'candy'} >>> first.update(second) >>> first {'a': 'agony', 'b': 'bagels', 'c': 'candy'} >>> first = {'a': 1, 'b': 2,'c':3,'d':4,'e':5} >>> second = {'b': 'platypus'} >>> first.update(second) >>> first {'a': 1, 'b': 'platypus', 'c': 3, 'd': 4, 'e': 5} Delete an Item by key with del >>> first = {'a': 'agony', 'b': 'bliss'} >>> del first['a'] >>> first {'b': 'bliss'} >>> del first['a'] Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'a' Get an Item by key and Delete It with pop() This combines get() and del.If you give pop() a key and it exists in the dictionary,it returns the matching value and deletes the key-value pair. If it doesn\u2019t exist, it raises an exception >>> first = {'a': 'agony', 'b': 'bliss'} >>> first.pop('a') 'agony' >>> first.pop('a') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> KeyError: 'a' >>> first.pop('a','nothing') 'nothing' Delete All Items with clear() To delete all keys and values from a dictionary,use clear() or just reassign an empty dictionary({}) to the name >>> A={'a': 1, 'b': 'platypus', 'c': 3, 'd': 4, 'e': 5} >>> A.clear() >>> A {} Test for a key with in >>> first = {'a': 1, 'b': 2,'c':3,'d':4,'e':5} >>> 'a' in first True >>> 'f' in first False Compare dictionaries Dictionaries can be compared with the simple comparison operators == and != >>> a = {1:1, 2:2, 3:3} >>> b = {3:3, 1:1, 2:2} >>> a == b True >>> a<b Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '<' not supported between instances of 'dict' and 'dict' Python compares the keys and values one by one. The order in which they were originally created doesn\u2019t matter >>> a = {1: [1, 2], 2: [1], 3:[1]} >>> b = {1: [1, 1], 2: [1], 3:[1]} >>> a!=b True Iterate with for and in >>> signals = {'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'} >>> for i in signals: ... print(i) ... green yellow red >>> for i in signals.keys(): ... print(i) ... green yellow red >>> for i in signals.values(): ... print(i) ... go go faster smile for the camera >>> for item in signals.items(): ... print(item) ... ('green', 'go') ('yellow', 'go faster') ('red', 'smile for the camera') >>> for key, value in signals.items(): ... print(key,'-',value) ... green - go yellow - go faster red - smile for the camera Create a dictionary from any iterable data type. >>> a = ['one','two','three','four'] >>> dict.fromkeys(a) {'one': None, 'two': None, 'three': None, 'four': None} popitem() : Remove and return a (key, value) pair as a 2-touple. Pairs are returned in LIFO (last-in, first-out) order. Raises KeyError if the dict is empty. >>> a = {1: [1, 1], 2: [1], 3: [1]} >>> a.popitem() (3, [1]) >>> a.popitem(1) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: popitem() takes no arguments (1 given) setdefault(): Insert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default. >>> a = {1: [1, 1], 2: [1], 3: [1]} >>> a.setdefault(4) >>> a a = {1: [1, 1], 2: [1], 3: [1], 4: None} >>> a.setdefault(1) [1,1] Got to top Home","title":"Dictionaries"},{"location":"comprehensions/","text":"List/Set/Dict Comprehensions Before you know about comprehensions. If you want to add a series of elements to list/set/dict we will use appropriate method. For instance we want to add element number from 1 to 5 to a list we could with the append() function like this: >>> l1 = list() #empty list >>> l1.append(1) >>> l1.append(2) >>> l1.append(3) >>> l1.append(4) >>> l1.append(5) >>> print(l1) [1,2,3,4,5] We can automate the same thing with for loop. >>> l2 = [] #empty list >>> for i in range(1,6): ... l2.append(i) ... >>> print(l2) [1,2,3,4,5] Another way of creating list using range() >>> l3 = list(range(1,6)) >>> l3 [1,2,3,4,5] All the mentioned techniques above are correct and produce correct result. Pythonic way to build a list is by using comprehensions. Simplest list comprehension is like this. syntax: [expression for item in iterable] >>> l4 = [i for i in range(1,6)] >>> l4 [1,2,3,4,5] same way in the sets >>> s1 = {i for i in range(1,6)} >>> s1 {1,2,3,4,5} In dictionary we have to specify key,value pairs. >>> d1={key:key*key for key in range(1,6)} >>> d1 {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} Comprehensions can include a conditional expression looking something like this syntax: expression for item in iterable if condition For list it would looks like this >>> odd_list = [number for number in range(1,6) if number%2!=0] >>> odd_list [1,3,5] In sets >>> odd_set = {number for number in range(1,6) if number%2!=0} >>> odd_set {1,3,5} In dictionary >>> d2 = {number:number*number for number in range(1,5) if number%2!=0} >>> d2 {1:1, 3:9} >>> rows = range(1,4) >>> cols = range(1,3) >>> for row in rows: ... for col in cols: ... print(row, col) ... 1 1 1 2 2 1 2 2 3 1 3 2 Lets use a comprehension and assign it to the variable cells, making it a list of (row, col) tuples: >>> rows = range(1,4) >>> cols = range(1,3) >>> cells = [(row, col) for row in rows for col in cols] >>> for cell in cells: ... print(cell) ... (1, 1) (1, 2) (2, 1) (2, 2) (3, 1) (3, 2) Home","title":"Comprehensions"},{"location":"comprehensions/#listsetdict-comprehensions","text":"Before you know about comprehensions. If you want to add a series of elements to list/set/dict we will use appropriate method. For instance we want to add element number from 1 to 5 to a list we could with the append() function like this: >>> l1 = list() #empty list >>> l1.append(1) >>> l1.append(2) >>> l1.append(3) >>> l1.append(4) >>> l1.append(5) >>> print(l1) [1,2,3,4,5] We can automate the same thing with for loop. >>> l2 = [] #empty list >>> for i in range(1,6): ... l2.append(i) ... >>> print(l2) [1,2,3,4,5] Another way of creating list using range() >>> l3 = list(range(1,6)) >>> l3 [1,2,3,4,5] All the mentioned techniques above are correct and produce correct result. Pythonic way to build a list is by using comprehensions. Simplest list comprehension is like this. syntax: [expression for item in iterable] >>> l4 = [i for i in range(1,6)] >>> l4 [1,2,3,4,5] same way in the sets >>> s1 = {i for i in range(1,6)} >>> s1 {1,2,3,4,5} In dictionary we have to specify key,value pairs. >>> d1={key:key*key for key in range(1,6)} >>> d1 {1: 1, 2: 4, 3: 9, 4: 16, 5: 25} Comprehensions can include a conditional expression looking something like this syntax: expression for item in iterable if condition For list it would looks like this >>> odd_list = [number for number in range(1,6) if number%2!=0] >>> odd_list [1,3,5] In sets >>> odd_set = {number for number in range(1,6) if number%2!=0} >>> odd_set {1,3,5} In dictionary >>> d2 = {number:number*number for number in range(1,5) if number%2!=0} >>> d2 {1:1, 3:9} >>> rows = range(1,4) >>> cols = range(1,3) >>> for row in rows: ... for col in cols: ... print(row, col) ... 1 1 1 2 2 1 2 2 3 1 3 2 Lets use a comprehension and assign it to the variable cells, making it a list of (row, col) tuples: >>> rows = range(1,4) >>> cols = range(1,3) >>> cells = [(row, col) for row in rows for col in cols] >>> for cell in cells: ... print(cell) ... (1, 1) (1, 2) (2, 1) (2, 2) (3, 1) (3, 2) Home","title":"List/Set/Dict Comprehensions"},{"location":"copying/","text":"Shallow copy and Deep copy Before we see about shallow copy and deep copy. We see how to assign any collection data type variable to another. >>> a = [1,2,3] >>> id(a) 1958952968712 >>> b=a >>> b [1,2,3] >>> id(b) 1958952968712 If you try to add an element to the b. It reflects in a also >>> b [1,2,3] >>> a [1,2,3] >>> b.append(4) >>> b [1,2,3,4] >>> a [1,2,3,4] Same way in sets >>> s1 = {1,2,3,4} >>> id(s1) 2110019791776 >>> s2 = s1 >>> s2 {1,2,3,4} >>> id(s2) 2110019791776 >>> s2.add(5) >>> s2 {1,2,3,4,5} >>> s1 {1,2,3,4,5} Dictionary also have the same issue >>> d1 = {'a':1,'b':2,'c':3} >>> id(d1) 2110019840000 >>> d2 = d1 >>> d2 {'a':1,'b':2,'c':3} >>> d2.update(d=4) >>> d2 {'a':1,'b':2,'c':3, 'd':4} >>> d1 {'a':1,'b':2,'c':3, 'd':4} Shallow copy A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original. with the copy() function we do shallow copying. >>> list1 = [['a','b'],['c','d']] >>> id(list1) 2110019822592 >>> list2 = list1.copy() >>> list2 [['a','b'],['c','d']] >>> id(list2) 2110019839936 >>> list2[0][1] = 'x' >>> list2 [['a','x'],['c','d']] >>> list1 [['a','x'],['c','d']] Same happens to dictionary >>> d1 = {1:['a','b'],2:['c','d']} >>> id(d1) 2110017714496 >>> d2 = d1.copy() >>> d2 {1:['a','b'],2:['c','d']} >>> id(d2) 2110017714432 >>> d2[1][1]='x' >>> d2 {1:['a','x'],2:['c','d']} >>> d1 {1:['a','x'],2:['c','d']} With the help of deepcopy(), we remedy this situation. Deep copy A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original. For this purpose we need to import module called copy >>> import copy >>> list1 = [['a','b'],['c','d']] >>> list2 = copy.deepcopy(list1) >>> list2[0][1] = 'x' >>> list2 [['a','x'],['c','d']] >>> list1 [['a','b'],['c','d']] Same way in dictionaries >>> import copy >>> d1 = {1:['a','b'],2:['c','d']} >>> d2 = copy.deepcopy(d1) >>> d2 {1:['a','b'],2:['c','d']} >>> d2[1][1]='x' >>> d2 {1:['a','x'],2:['c','d']} >>> d1 {1:['a','b'],2:['c','d']} Home","title":"Shallow Copy and Deep Copy"},{"location":"copying/#shallow-copy-and-deep-copy","text":"Before we see about shallow copy and deep copy. We see how to assign any collection data type variable to another. >>> a = [1,2,3] >>> id(a) 1958952968712 >>> b=a >>> b [1,2,3] >>> id(b) 1958952968712 If you try to add an element to the b. It reflects in a also >>> b [1,2,3] >>> a [1,2,3] >>> b.append(4) >>> b [1,2,3,4] >>> a [1,2,3,4] Same way in sets >>> s1 = {1,2,3,4} >>> id(s1) 2110019791776 >>> s2 = s1 >>> s2 {1,2,3,4} >>> id(s2) 2110019791776 >>> s2.add(5) >>> s2 {1,2,3,4,5} >>> s1 {1,2,3,4,5} Dictionary also have the same issue >>> d1 = {'a':1,'b':2,'c':3} >>> id(d1) 2110019840000 >>> d2 = d1 >>> d2 {'a':1,'b':2,'c':3} >>> d2.update(d=4) >>> d2 {'a':1,'b':2,'c':3, 'd':4} >>> d1 {'a':1,'b':2,'c':3, 'd':4}","title":"Shallow copy and Deep copy"},{"location":"copying/#shallow-copy","text":"A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original. with the copy() function we do shallow copying. >>> list1 = [['a','b'],['c','d']] >>> id(list1) 2110019822592 >>> list2 = list1.copy() >>> list2 [['a','b'],['c','d']] >>> id(list2) 2110019839936 >>> list2[0][1] = 'x' >>> list2 [['a','x'],['c','d']] >>> list1 [['a','x'],['c','d']] Same happens to dictionary >>> d1 = {1:['a','b'],2:['c','d']} >>> id(d1) 2110017714496 >>> d2 = d1.copy() >>> d2 {1:['a','b'],2:['c','d']} >>> id(d2) 2110017714432 >>> d2[1][1]='x' >>> d2 {1:['a','x'],2:['c','d']} >>> d1 {1:['a','x'],2:['c','d']} With the help of deepcopy(), we remedy this situation.","title":"Shallow copy"},{"location":"copying/#deep-copy","text":"A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original. For this purpose we need to import module called copy >>> import copy >>> list1 = [['a','b'],['c','d']] >>> list2 = copy.deepcopy(list1) >>> list2[0][1] = 'x' >>> list2 [['a','x'],['c','d']] >>> list1 [['a','b'],['c','d']] Same way in dictionaries >>> import copy >>> d1 = {1:['a','b'],2:['c','d']} >>> d2 = copy.deepcopy(d1) >>> d2 {1:['a','b'],2:['c','d']} >>> d2[1][1]='x' >>> d2 {1:['a','x'],2:['c','d']} >>> d1 {1:['a','b'],2:['c','d']} Home","title":"Deep copy"},{"location":"createGithub/","text":"What is Github ? GitHub provides hosting for software development. It also provides version control using Git. It offers distributed version control. It offers source code management(SCM) functionality of Git. It provides access control and several collaborations features such as bug tracking, feature requests, task management, and wikis for every project. It offers basic services free of cost. Create GitHub account Goto the GitHub website (https://github.com/) Sign up for GitHub Sign in to your github account. Create a new repository Now you are done. We will see later how to save our program files in this repository. Go back","title":"Github account"},{"location":"createGithub/#what-is-github","text":"GitHub provides hosting for software development. It also provides version control using Git. It offers distributed version control. It offers source code management(SCM) functionality of Git. It provides access control and several collaborations features such as bug tracking, feature requests, task management, and wikis for every project. It offers basic services free of cost.","title":"What is Github ?"},{"location":"createGithub/#create-github-account","text":"Goto the GitHub website (https://github.com/) Sign up for GitHub Sign in to your github account. Create a new repository Now you are done. We will see later how to save our program files in this repository. Go back","title":"Create GitHub account"},{"location":"dpattrens/","text":"Design Patterns Adapter Pattern Adapter is a structural design pattern, which allows incompatible objects to collaborate. The Adapter acts as a wrapper between two objects. It catches calls for one object and transforms them to format and interface recognizable by the second object. Lets assume we have exisiting class called LegacyRectangle. It would look like this: class LegacyRectangle: def __init__(self, length, breadth): self.__length = length self.__breadth = breadth def area_calculation(self): return self.__length * self.__breadth def draw(self): print(\"This draws a legacy rectangle to screen\") We have one more class called LegacySquare. That would look like this: class LegacySquare: def __init__(self, side): self.__side = side def area(self): return self.__side * self.__side def draw_me(self): print(\"This draws a legacy square to screen\") Now lets create objects for LegacyRectangle and LegacySquare classes >>> l_rectangle = LegacyRectangle(5,6) >>> l_rectangle.area_calculation() 30 >>> l_square = LegacySquare(5) >>> l_square.area() 25 Now lets say we have requirment that all the shapes i.e rectangle, square etc bring into single interface in such scenario we need to create interface called shape. Lets create an interface called shape here class shape: def __init__(self,shape_type): self.__shape_type = shape_type def get_area(self): pass def render(self): pass Now If we create a new shape called circle that class would look like this: import math class Circle(shape): def __init__(self,radius): shape.__init__(self,'circle') self.__radius = radius def get_area(self): return math.pi*self.__radius*self.__radius def render(self): print(\"This draws circle here\") Now lets create two functions that can call the methods of shape: def render_shape(shape): shape.render() def calculate_area(shape): return shape.get_area() Now lets create an object for circle and call the methods render_shape and calculate_area on the circle: >>> circle = Circle(10) >>> render_shape(circle) This draws a circle to screen( >>> calculate_area(circle) 314.1592653589293 You can see that we can call render_shape or calculate_area it on circle they gave result successfully. But if you try to call those functions on LegacySquare or LegacyRectangle what happens let us see. >>> render_shape(l_rectangle) AttributeError: 'LegacyRectangle' object has no attribute 'render' >>> render_shape(l_square) AttributeError: 'LegacySquare' object has no attribute 'render' So we will encounter the errors. To overcome this we need to create adapter classes for both LegacyRectangle and LegacySquare. Lets create adapter classes for both the classes here: class LegacyRectangleAdapter(Shape): def __init__(self,legacy_rectangle): Shape.__init__(self,'Rectangle') self.__legacy_rectangle = legacy_rectangle def get_area(self): return self.__legacy_rectangle.area_calculation() def render(self): self.__legacy_square.draw() so the LegacySquare class: class LegacySquareAdapter(Shape): def __init__(self, legacy_square): Shape.__init__(self,'Square') self.__legacy_square = legacy_square def get_area(self): return self.__legacy_square.area() def render(self): self.__legacy_square.draw_me() Now we can able to call calculate_area() and render() methods for both LegacyRectangle and LegacySquare() with the help of newly created classes LegacyRectangleAdapter and LegacySquareAdapter. Let's see that >>> l_rectangleadapter = LegacyRectangleAdapter(l_rectangle) >>> l_squareadapter = LegacySquareAdapter(l_square) >>> calculate_area(l_rectangleadaptor) 30 >>> calculate_area(l_squareadaptor) 25 >>> render_shape(l_rectangleadaptor) This draws a legacy rectangle to screen >>> render_shape(l_squareadaptor) This draws a legacy square to screen The above example demonstrated you about adapter pattren The Decorator pattern Use this pattren to exploit chained relationships. It adds responsibilites to objects dynamically Behaviour needs to be added at runime. Inheritance will not work since it is static.","title":"Design Pattrens"},{"location":"dpattrens/#design-patterns","text":"","title":"Design Patterns"},{"location":"dpattrens/#adapter-pattern","text":"Adapter is a structural design pattern, which allows incompatible objects to collaborate. The Adapter acts as a wrapper between two objects. It catches calls for one object and transforms them to format and interface recognizable by the second object. Lets assume we have exisiting class called LegacyRectangle. It would look like this: class LegacyRectangle: def __init__(self, length, breadth): self.__length = length self.__breadth = breadth def area_calculation(self): return self.__length * self.__breadth def draw(self): print(\"This draws a legacy rectangle to screen\") We have one more class called LegacySquare. That would look like this: class LegacySquare: def __init__(self, side): self.__side = side def area(self): return self.__side * self.__side def draw_me(self): print(\"This draws a legacy square to screen\") Now lets create objects for LegacyRectangle and LegacySquare classes >>> l_rectangle = LegacyRectangle(5,6) >>> l_rectangle.area_calculation() 30 >>> l_square = LegacySquare(5) >>> l_square.area() 25 Now lets say we have requirment that all the shapes i.e rectangle, square etc bring into single interface in such scenario we need to create interface called shape. Lets create an interface called shape here class shape: def __init__(self,shape_type): self.__shape_type = shape_type def get_area(self): pass def render(self): pass Now If we create a new shape called circle that class would look like this: import math class Circle(shape): def __init__(self,radius): shape.__init__(self,'circle') self.__radius = radius def get_area(self): return math.pi*self.__radius*self.__radius def render(self): print(\"This draws circle here\") Now lets create two functions that can call the methods of shape: def render_shape(shape): shape.render() def calculate_area(shape): return shape.get_area() Now lets create an object for circle and call the methods render_shape and calculate_area on the circle: >>> circle = Circle(10) >>> render_shape(circle) This draws a circle to screen( >>> calculate_area(circle) 314.1592653589293 You can see that we can call render_shape or calculate_area it on circle they gave result successfully. But if you try to call those functions on LegacySquare or LegacyRectangle what happens let us see. >>> render_shape(l_rectangle) AttributeError: 'LegacyRectangle' object has no attribute 'render' >>> render_shape(l_square) AttributeError: 'LegacySquare' object has no attribute 'render' So we will encounter the errors. To overcome this we need to create adapter classes for both LegacyRectangle and LegacySquare. Lets create adapter classes for both the classes here: class LegacyRectangleAdapter(Shape): def __init__(self,legacy_rectangle): Shape.__init__(self,'Rectangle') self.__legacy_rectangle = legacy_rectangle def get_area(self): return self.__legacy_rectangle.area_calculation() def render(self): self.__legacy_square.draw() so the LegacySquare class: class LegacySquareAdapter(Shape): def __init__(self, legacy_square): Shape.__init__(self,'Square') self.__legacy_square = legacy_square def get_area(self): return self.__legacy_square.area() def render(self): self.__legacy_square.draw_me() Now we can able to call calculate_area() and render() methods for both LegacyRectangle and LegacySquare() with the help of newly created classes LegacyRectangleAdapter and LegacySquareAdapter. Let's see that >>> l_rectangleadapter = LegacyRectangleAdapter(l_rectangle) >>> l_squareadapter = LegacySquareAdapter(l_square) >>> calculate_area(l_rectangleadaptor) 30 >>> calculate_area(l_squareadaptor) 25 >>> render_shape(l_rectangleadaptor) This draws a legacy rectangle to screen >>> render_shape(l_squareadaptor) This draws a legacy square to screen The above example demonstrated you about adapter pattren","title":"Adapter Pattern"},{"location":"dpattrens/#the-decorator-pattern","text":"Use this pattren to exploit chained relationships. It adds responsibilites to objects dynamically Behaviour needs to be added at runime. Inheritance will not work since it is static.","title":"The Decorator pattern"},{"location":"funcs/","text":"Functions Functions are first class objects in python. Function is a piece of code or set of instructions to carry out specific task. Functions may take single or multipule inputs to carry out the the task and sometimes they may not take input. After carried out specific task, functions may return single or multipule values or may not return any values. There are three types of functions available in python: Built-in Functions Built-in functions comes up with python. There are different built-in functions are avialble. You can find about Built-in functions here User Defined Functions(UDF) The keyword def introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the function\u2019s documentation string, or docstring. End your function with a return statement if the function should output something. Without the return statement, your function will return an object None. Syntax: def functionName(<parsmeters>): \"\"\"function documentation goes here\"\"\"\" code goes here return something or nothing Syntax for calling the function functionName(<parametervalues>) Example 1: simple function def greeting(): \"\"\"greeting will greet you\"\"\" return \"Welcome to python functions\" We can call the above declared function greeting like this: greeting() #return 'Welcome to python functions' The above function call will return Welcome to python functions If you try the greeting. doc . It will print : greeting will greet you Docstrings are very useful for the programmers to know what really the function does. Example 2: Creating a function with parameters(s): def greeting(a): \"\"\"greeting requires 1 argument to greet you\"\"\" return a+' Welcome to python functions' You need to call greeting function with the argument. greeting('Joshua') #str given as an argument This will return us the output: Joshua Welcome to python functions You can store the function call in another variable like this b = greeting(\"Blake\") print(b) output: Blake Welcome to python functions If you call the function greeting without passing argument, it will throw exception like this: TypeError: greeting() missing 1 required positional argument: 'a' There are different types of arguments available in python functions. If you pass other than string argument to greeting , It will throw exception.To overcome this we need to modify function definition like this: def greeting(a): \"\"\"greeting requires 1 argument to greet you\"\"\" return f'{a} Welcome to python functions' Now you can call the function by passing any data type argument. greeting(b'Bob') That will give us the output: \"b'Bob' Welcome to python functions\" Example 3: Lets take one more function called add with two parameters def add(a,b): \"\"\"Add two variables and return sum of it\"\"\" return a+b You need to pass the two arguments to call the add . add(10,120) It will return 130 Parameters vs Arguments Parameters are the names used when defining a function or a method, and into which arguments will be mapped. In other words, arguments are the things which are supplied to any function or method call, while the function or method code refers to the arguments by their parameter names. Positional arguments Positional arguments are arguments that can be called by their position in the function definition. Example 3: def posfunc(a,b,c): \"\"\"Demo about positional arguments\"\"\" return f'a={a}\\nb={b}\\nc={c}' You required to pass the three arguments to the function posfunc in same order. posfunc(1, 2, 3) posfunc will return the output: a=1 b=2 c=3 Another way of passing positional arguments is like this: posfunc(*(5,6,7)) That will return the output: 5 6 7 Keyword arguments Keyword arguments are arguments that must call by their name. Example 4: def keyfunc(a,b,c): \"\"\"Demo about keyword arguments\"\"\" return f'a={a}\\nb={b}\\nc={c}' You need to call the function keyfunc arguments by their name: keyfunc(a=1,b=2,c=3) Above function will return a=1 b=2 c=3 You can change the position of arguments if you want to call arguments by keyword. keyfunc(b=2,a=1,c=3) Above function call will result the output. a=1 b=2 c=3 Another way of calling function with keyword arguments is: keyfunc(**{'a':7,'b':8,'c':9}) That will return the output: a=7 b=8 c=9 Position-only Parameters If positional-only, the parameters\u2019 order matters, and the parameters cannot be passed by keyword. Positional-only parameters are placed before a / (forward-slash). The / is used to logically separate the positional-only parameters from the rest of the parameters. If there is no / in the function definition, there are no positional-only parameters. def pos_only_arg(arg, /): \"\"\"demo on position only arguments\"\"\" print(arg) pos_only_arg(1) will return 1. But if you try to call the function like this pos_only_arg(arg=1) . It gives you exception. TypeError: pos_only_arg() got some positional-only arguments passed as key word arguments: 'arg' Default arguments or Optional arguments Optional arguments or Default arguments are arguments that may not be passed to the function. Because they contains default value. Default parameter values are evaluated from left to right when the function definition is executed. Example 5: def defunc(a=1,b=2,c=3): \"\"\"default arguments demonstration\"\"\" return f'a={a}/t b={b} /t c={c}' You could call this function without passing arguments like this: defunc() That will return the output like this: a=1 b=2 c=3 If you want to overwrite default values in the function you could do that by passing argument as a positional or keyword to the function call defunc(2) #positional argument The above call will overwrites first argument value, in this case a a=2 b=2 c=3 You could also overwrite default value by using keyword argument. defunc(c=99) The above function call will return us. a=1 b=2 c=99 Caution: You should not pass positional and keyword arguments for the same parmeter. For example if you pass positional argument then try to pass keyword argument to the same parameter it will throw us exception. defunc(5,a=555) This call will throw an exception like this: TypeError: defunc() got multiple values for argument 'a' Note: You need to pass positional arguments followed by keyword arguments. defunc(2,b=3) That will return us the output: a=2 b=3 c=3 But if you try to pass other way you will get exception: defunc(a=5,777) The output would be like this: SyntaxError: positional argument follows keyword argument Keyword-Only Arguments To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an * in the arguments list just before the first keyword-only parameter. def kwd_only_arg(*, arg): \"\"\"Demo on Keyword-only arguments\"\"\" print(arg) If you call the above function like this kwd_only_arg(3) . It will throw you exception. TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given kwd_only_arg(arg=3) will print 3. Special parameters By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword. Syntax: def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only where / and * are optional If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: positional-only, positional-or-keyword, and keyword-only. Keyword parameters are also referred to as named parameters. In some scenarios arguments size varies for the same function in different scenarios. You could pass as many arguments as you want to function with the help of * . Example: def demo(*arg): \"\"\"Dealing with multipule arguments\"\"\" return arg You could pass as many arguments you can. Above function return all the passed arguments in the form of tuples. demo(1,2,'a',True,13.6) Above function call return us this output: (1,2,'a',True,13.6) But if you try to call the function with keyword arguments. You will get exception. demo(a=1,b=2,c=3) The above function call gives you exception. TypeError: demo() got an unexpected keyword argument 'a' If you want to call the function with keyword arguments . You could do by mentioning ** before to the parameter. def demofunc(**kwargs): \"\"\"Demo on variable names and their values\"\"\" return kwargs You have to call the function with variable names and their values: demofunc(a=1,b=2,c=3) Above called function will return parameter name which is passed during the function call and its value as a form of dictionary. {'a': 1, 'b': 2, 'c': 3} But if you try calling the function with positional arguments, you will get exception. demofunc(1,2,3) Above function call gives you exception. TypeError: demofunc() takes 0 positional arguments but 3 were given If you want to pass both positional and keyword arguments. First you need to pass positional arguments and then keyword arguments. Function definition would looks like this. def combo(*arg, **kwargs): return arg, kwargs Above function will return in the form of tuple. combo('a','b','c',a=1,b=2,c=3) Above function call returns (('a','b','c'),{a:1,b:2,c:3}) You could decare like this: def f(par, *arg, **kwarg) print(par, *arg, **kwarg) Call the above function like this f(1,2,34,5,a='x',b='y',c='z') will print: 1 (2,34,5) {'a':'x','b':'y','c':'z'} But if you try call like this f(par=1,2,34,5,a='x',b='y',c='z') you will get exception like this: SyntaxError: positional argument follows keyword argument To resolve this exception you have to define like this: def f(*arg,par, **kwarg): print(arg, par, kwarg) So you could call the function like this f(1,2,34,par=5,a='x',b='y',c='z') that will print the result without giving any exception. Anonymus Functions Anonymus function is a function that could be declared without name, anonymus function can be declared using lambda . Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Like nested function definitions, lambda functions can reference variables from the containing scope. lambda x: x In the above example lambda is keyword, x is a bound variable and the body is x . Above lambda expression is equivalent to the following function. def f(x): return x You could call the above declared lambda function like this. (lambda x: x)(2) That will return 2. One more example: (lambda x: x+1)(2) That will produce the output 3. Another way of calling anonymous function is a = lambda x: x Now variable a will be act as a function. a(1) Above call will return 1. Few more examples on the function is full_name = lambda first, last: f'{first.title()} {last.title()}' You could call this function full_name('paul','walker') That will give us the output Paul Walker LEGB Rule LEGB Rule","title":"Functions"},{"location":"funcs/#functions","text":"Functions are first class objects in python. Function is a piece of code or set of instructions to carry out specific task. Functions may take single or multipule inputs to carry out the the task and sometimes they may not take input. After carried out specific task, functions may return single or multipule values or may not return any values. There are three types of functions available in python:","title":"Functions"},{"location":"funcs/#built-in-functions","text":"Built-in functions comes up with python. There are different built-in functions are avialble. You can find about Built-in functions here","title":"Built-in Functions"},{"location":"funcs/#user-defined-functionsudf","text":"The keyword def introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented. The first statement of the function body can optionally be a string literal; this string literal is the function\u2019s documentation string, or docstring. End your function with a return statement if the function should output something. Without the return statement, your function will return an object None. Syntax: def functionName(<parsmeters>): \"\"\"function documentation goes here\"\"\"\" code goes here return something or nothing Syntax for calling the function functionName(<parametervalues>) Example 1: simple function def greeting(): \"\"\"greeting will greet you\"\"\" return \"Welcome to python functions\" We can call the above declared function greeting like this: greeting() #return 'Welcome to python functions' The above function call will return Welcome to python functions If you try the greeting. doc . It will print : greeting will greet you Docstrings are very useful for the programmers to know what really the function does. Example 2: Creating a function with parameters(s): def greeting(a): \"\"\"greeting requires 1 argument to greet you\"\"\" return a+' Welcome to python functions' You need to call greeting function with the argument. greeting('Joshua') #str given as an argument This will return us the output: Joshua Welcome to python functions You can store the function call in another variable like this b = greeting(\"Blake\") print(b) output: Blake Welcome to python functions If you call the function greeting without passing argument, it will throw exception like this: TypeError: greeting() missing 1 required positional argument: 'a' There are different types of arguments available in python functions. If you pass other than string argument to greeting , It will throw exception.To overcome this we need to modify function definition like this: def greeting(a): \"\"\"greeting requires 1 argument to greet you\"\"\" return f'{a} Welcome to python functions' Now you can call the function by passing any data type argument. greeting(b'Bob') That will give us the output: \"b'Bob' Welcome to python functions\" Example 3: Lets take one more function called add with two parameters def add(a,b): \"\"\"Add two variables and return sum of it\"\"\" return a+b You need to pass the two arguments to call the add . add(10,120) It will return 130","title":"User Defined Functions(UDF)"},{"location":"funcs/#parameters-vs-arguments","text":"Parameters are the names used when defining a function or a method, and into which arguments will be mapped. In other words, arguments are the things which are supplied to any function or method call, while the function or method code refers to the arguments by their parameter names.","title":"Parameters vs Arguments"},{"location":"funcs/#positional-arguments","text":"Positional arguments are arguments that can be called by their position in the function definition. Example 3: def posfunc(a,b,c): \"\"\"Demo about positional arguments\"\"\" return f'a={a}\\nb={b}\\nc={c}' You required to pass the three arguments to the function posfunc in same order. posfunc(1, 2, 3) posfunc will return the output: a=1 b=2 c=3 Another way of passing positional arguments is like this: posfunc(*(5,6,7)) That will return the output: 5 6 7","title":"Positional arguments"},{"location":"funcs/#keyword-arguments","text":"Keyword arguments are arguments that must call by their name. Example 4: def keyfunc(a,b,c): \"\"\"Demo about keyword arguments\"\"\" return f'a={a}\\nb={b}\\nc={c}' You need to call the function keyfunc arguments by their name: keyfunc(a=1,b=2,c=3) Above function will return a=1 b=2 c=3 You can change the position of arguments if you want to call arguments by keyword. keyfunc(b=2,a=1,c=3) Above function call will result the output. a=1 b=2 c=3 Another way of calling function with keyword arguments is: keyfunc(**{'a':7,'b':8,'c':9}) That will return the output: a=7 b=8 c=9","title":"Keyword arguments"},{"location":"funcs/#position-only-parameters","text":"If positional-only, the parameters\u2019 order matters, and the parameters cannot be passed by keyword. Positional-only parameters are placed before a / (forward-slash). The / is used to logically separate the positional-only parameters from the rest of the parameters. If there is no / in the function definition, there are no positional-only parameters. def pos_only_arg(arg, /): \"\"\"demo on position only arguments\"\"\" print(arg) pos_only_arg(1) will return 1. But if you try to call the function like this pos_only_arg(arg=1) . It gives you exception. TypeError: pos_only_arg() got some positional-only arguments passed as key word arguments: 'arg'","title":"Position-only Parameters"},{"location":"funcs/#default-arguments-or-optional-arguments","text":"Optional arguments or Default arguments are arguments that may not be passed to the function. Because they contains default value. Default parameter values are evaluated from left to right when the function definition is executed. Example 5: def defunc(a=1,b=2,c=3): \"\"\"default arguments demonstration\"\"\" return f'a={a}/t b={b} /t c={c}' You could call this function without passing arguments like this: defunc() That will return the output like this: a=1 b=2 c=3 If you want to overwrite default values in the function you could do that by passing argument as a positional or keyword to the function call defunc(2) #positional argument The above call will overwrites first argument value, in this case a a=2 b=2 c=3 You could also overwrite default value by using keyword argument. defunc(c=99) The above function call will return us. a=1 b=2 c=99 Caution: You should not pass positional and keyword arguments for the same parmeter. For example if you pass positional argument then try to pass keyword argument to the same parameter it will throw us exception. defunc(5,a=555) This call will throw an exception like this: TypeError: defunc() got multiple values for argument 'a' Note: You need to pass positional arguments followed by keyword arguments. defunc(2,b=3) That will return us the output: a=2 b=3 c=3 But if you try to pass other way you will get exception: defunc(a=5,777) The output would be like this: SyntaxError: positional argument follows keyword argument","title":"Default arguments or Optional arguments"},{"location":"funcs/#keyword-only-arguments","text":"To mark parameters as keyword-only, indicating the parameters must be passed by keyword argument, place an * in the arguments list just before the first keyword-only parameter. def kwd_only_arg(*, arg): \"\"\"Demo on Keyword-only arguments\"\"\" print(arg) If you call the above function like this kwd_only_arg(3) . It will throw you exception. TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given kwd_only_arg(arg=3) will print 3.","title":"Keyword-Only Arguments"},{"location":"funcs/#special-parameters","text":"By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword. Syntax: def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): ----------- ---------- ---------- | | | | Positional or keyword | | - Keyword only -- Positional only where / and * are optional If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: positional-only, positional-or-keyword, and keyword-only. Keyword parameters are also referred to as named parameters. In some scenarios arguments size varies for the same function in different scenarios. You could pass as many arguments as you want to function with the help of * . Example: def demo(*arg): \"\"\"Dealing with multipule arguments\"\"\" return arg You could pass as many arguments you can. Above function return all the passed arguments in the form of tuples. demo(1,2,'a',True,13.6) Above function call return us this output: (1,2,'a',True,13.6) But if you try to call the function with keyword arguments. You will get exception. demo(a=1,b=2,c=3) The above function call gives you exception. TypeError: demo() got an unexpected keyword argument 'a' If you want to call the function with keyword arguments . You could do by mentioning ** before to the parameter. def demofunc(**kwargs): \"\"\"Demo on variable names and their values\"\"\" return kwargs You have to call the function with variable names and their values: demofunc(a=1,b=2,c=3) Above called function will return parameter name which is passed during the function call and its value as a form of dictionary. {'a': 1, 'b': 2, 'c': 3} But if you try calling the function with positional arguments, you will get exception. demofunc(1,2,3) Above function call gives you exception. TypeError: demofunc() takes 0 positional arguments but 3 were given If you want to pass both positional and keyword arguments. First you need to pass positional arguments and then keyword arguments. Function definition would looks like this. def combo(*arg, **kwargs): return arg, kwargs Above function will return in the form of tuple. combo('a','b','c',a=1,b=2,c=3) Above function call returns (('a','b','c'),{a:1,b:2,c:3}) You could decare like this: def f(par, *arg, **kwarg) print(par, *arg, **kwarg) Call the above function like this f(1,2,34,5,a='x',b='y',c='z') will print: 1 (2,34,5) {'a':'x','b':'y','c':'z'} But if you try call like this f(par=1,2,34,5,a='x',b='y',c='z') you will get exception like this: SyntaxError: positional argument follows keyword argument To resolve this exception you have to define like this: def f(*arg,par, **kwarg): print(arg, par, kwarg) So you could call the function like this f(1,2,34,par=5,a='x',b='y',c='z') that will print the result without giving any exception.","title":"Special parameters"},{"location":"funcs/#anonymus-functions","text":"Anonymus function is a function that could be declared without name, anonymus function can be declared using lambda . Lambda functions can be used wherever function objects are required. They are syntactically restricted to a single expression. Like nested function definitions, lambda functions can reference variables from the containing scope. lambda x: x In the above example lambda is keyword, x is a bound variable and the body is x . Above lambda expression is equivalent to the following function. def f(x): return x You could call the above declared lambda function like this. (lambda x: x)(2) That will return 2. One more example: (lambda x: x+1)(2) That will produce the output 3. Another way of calling anonymous function is a = lambda x: x Now variable a will be act as a function. a(1) Above call will return 1. Few more examples on the function is full_name = lambda first, last: f'{first.title()} {last.title()}' You could call this function full_name('paul','walker') That will give us the output Paul Walker","title":"Anonymus Functions"},{"location":"funcs/#legb-rule","text":"LEGB Rule","title":"LEGB Rule"},{"location":"installPython/","text":"Install in windows Goto the website https://www.python.org/downloads/ Download the latest version of python(3.8) Install the python. After completion of the install verify the status by opening the command prompt and type python If you see the status like above mentioned image, yeah! You succesfully installed python. Go back","title":"Python Installation"},{"location":"installPython/#install-in-windows","text":"Goto the website https://www.python.org/downloads/ Download the latest version of python(3.8) Install the python. After completion of the install verify the status by opening the command prompt and type python If you see the status like above mentioned image, yeah! You succesfully installed python. Go back","title":"Install in windows"},{"location":"list_quiz/","text":"","title":"List quiz"},{"location":"pythonfirststeps/","text":"First steps in python Open the command prompt and type 'python' You will get REPL editor R ead E valuate P rint L oop >>> 2+2 4 >>> 6*7 42 >>> x = 5 >>> x 5 >>> 3*x 15 >>> _*2 30 >>> print('Hello Python') Hello Python Difference between Python 2 and Python 3 In python 2 print stmt: >>> print 'Hello Python' Hello Python But in python 3 print stmt is a function which is having the parenthesis >>> print('Hello world') Hello world To close the REPL editor use ctrl+z, and In Linux/Mac use ctrl+d to exit from the REPL editor. Significant whitespace Python follows indentation in code blocks. >>> for i in range(5): ... x = i*10 # giving spaces(4) is a indented code block ... print(x) 0 10 20 30 40 Python expects us: - Readable code - No clutter - Human and computer can't get out of sync Important points to remember: - Prefer 4 spaces instead of - Never mix spaces and tables - Be consistent on consuctive lines. - Only deviate to improve readability The above mentioned approach is called \"Programming as Guido intended(indented) it\". Python culture The development of python managed through a series of documents called PEPs(Python Enhancement Proposels). One of the PEP is PEP8, that describes about the style guide for python code and It recommended 4 spaces indentation. ZEN of Python(PEP-20): >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Using the standard library It is often refers battery includes You can access standard library by using 'import' keyword. Syntax: import module_name >>> import math >>> math.sqrt(9) 3.0 >>> help Type help() for interactive help, or help(object) for help about object. >>> math.factorial(5) 120 >>> math.factorial(17) 355687428096000 >>> n = 5 >>> k = 3 >>> math.factorial(n)/(math.factorial(k) * math.factorial(n-k)) 10.0 >>> from math import factorial as fac >>> fac(n)/(fac(k)*fac(n-k)) 10.0 >>> fac(n)//(fac(k)*fac(n-k)) 10 Go back","title":"Python First steps"},{"location":"pythonfirststeps/#first-steps-in-python","text":"Open the command prompt and type 'python' You will get REPL editor R ead E valuate P rint L oop >>> 2+2 4 >>> 6*7 42 >>> x = 5 >>> x 5 >>> 3*x 15 >>> _*2 30 >>> print('Hello Python') Hello Python","title":"First steps in python"},{"location":"pythonfirststeps/#difference-between-python-2-and-python-3","text":"In python 2 print stmt: >>> print 'Hello Python' Hello Python But in python 3 print stmt is a function which is having the parenthesis >>> print('Hello world') Hello world To close the REPL editor use ctrl+z, and In Linux/Mac use ctrl+d to exit from the REPL editor.","title":"Difference between Python 2 and Python 3"},{"location":"pythonfirststeps/#significant-whitespace","text":"Python follows indentation in code blocks. >>> for i in range(5): ... x = i*10 # giving spaces(4) is a indented code block ... print(x) 0 10 20 30 40 Python expects us: - Readable code - No clutter - Human and computer can't get out of sync Important points to remember: - Prefer 4 spaces instead of - Never mix spaces and tables - Be consistent on consuctive lines. - Only deviate to improve readability The above mentioned approach is called \"Programming as Guido intended(indented) it\".","title":"Significant whitespace"},{"location":"pythonfirststeps/#python-culture","text":"The development of python managed through a series of documents called PEPs(Python Enhancement Proposels). One of the PEP is PEP8, that describes about the style guide for python code and It recommended 4 spaces indentation. ZEN of Python(PEP-20): >>> import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!","title":"Python culture"},{"location":"pythonfirststeps/#using-the-standard-library","text":"It is often refers battery includes You can access standard library by using 'import' keyword. Syntax: import module_name >>> import math >>> math.sqrt(9) 3.0 >>> help Type help() for interactive help, or help(object) for help about object. >>> math.factorial(5) 120 >>> math.factorial(17) 355687428096000 >>> n = 5 >>> k = 3 >>> math.factorial(n)/(math.factorial(k) * math.factorial(n-k)) 10.0 >>> from math import factorial as fac >>> fac(n)/(fac(k)*fac(n-k)) 10.0 >>> fac(n)//(fac(k)*fac(n-k)) 10 Go back","title":"Using the standard library"},{"location":"scalartypes/","text":"Scalar data types integer data type int: unlimited precision signed integer >>> 10 10 >>> type(10) <class 'int'> >>> x = 15 >>>x 15 >>> type(x) <class 'int'> >>> 0b1010 10 >>> bin(10) '0b1010' >>> 0o10 8 >>> oct(8) '0o10' >>> 0x145 325 >>> hex(325) '0x145' >>> int(3.5) 3 >>> int(-3.5) -3 >>> int(\"496\") 496 >>> int(\"1000\",3) 27 float data type floating points are supported by float type. python floats are implemented IEEE-754 double-precision with 53-bits of binary precision. This is equivalent to 15-16 significant digits in decimal. >>> 3.125 3.125 >>> 3e8 300000000.0 >>> 1.616e-35 1.616e-35 >>> x = 3.14 >>> x 3.14 >>> type(x) <class 'float'> >>> float(7) 7.0 >>> float(\"1.618\") 1.618 >>> float(\"nan\") nan >>> float(\"inf\") inf >>> float(\"-inf\") -inf >>> 3.0+1 4.0 None data type python has special null value called \"None\". None is frequently reprsent the absent of value. >>> None >>> a=None >>> a is None True >>> type(None) <class 'NoneType'> bool data type Boolean logical values used in control structures >>> True True >>> False False >>> bool(0) False >>> bool(42) True >>> bool(-1) True >>> bool(0.0) False >>> bool(0.207) True >>> bool(-1.117) True >>> bool([]) False >>> bool([1,5,9]) True >>> bool(\"\") False >>> bool(\"spam\") True >>> bool(\"False\") True >>> bool(\"True\") True Bool values commonly produces by python relational operators. Relational operators are used to comparing the objects. operator meaning == value equality / equivalence != inequality / inequivalence < less-than > greater-than <= less-than or equal to >= greater-than or equal to >>> g=20 >>> g == 20 True >>> g == 13 False >>> g!= 20 False >>> g < 30 True >>> g <= 20 True >>> g>30 False >>> g >= 20 True control flow : conditional statement : Branch execution based on the value of an expression. if : Syntax: if expression: block >>> if True: ... print(\"It's true!\") ... It's true! >>> if False: ... print('It's false!') ... >>> if bool('eggs'): ... print('Yes please!') ... Yes please! >>> if \"eggs\": ... print(\"Yes please!\") ... Yes please! else clause: >>> h=42 >>> if h>50: ... print('Greater than 50') ... else: ... print('50 or smaller') 50 or smaller >>> if h > 50 : ... print('Greater than 50') ... else: ... if h<20: ... print('Lessthan 20') ... else: ... print('Between 20 and 50') Between 20 and 50 >>> if h>50: ... print('Greater than 50') ... elif h<20: ... print('less than 50') ... else: ... print('Between 20 and 50') Between 20 and 50 while loops: syntax: while expression: <body> >>> c = 5 >>> while c!=0: ... print(c) ... c-=1 ... 5 4 3 2 1 >>> c=5 >>> while c: ... print(c) ... c-=1 ... 5 4 3 2 1 while loop often used as infinite loops in python. >>> while True: ... pass ... press ctrl+c KeyboardInterrupt break: Many programming languages support a loop ending in predicate test. python rerquires to use while True and break break jumps out of the inner-most executing loop the line immediatley after it. >>> while True: ... response = input() ... if int(response)%7 == 0 : ... break ... 12 24 67 34 28 Int truthiness >>> bool(5) == True True >>> bool(4) == True True >>> bool(0) == False False Go back","title":"Scalar Data Types"},{"location":"scalartypes/#scalar-data-types","text":"","title":"Scalar data types"},{"location":"scalartypes/#integer-data-type","text":"int: unlimited precision signed integer >>> 10 10 >>> type(10) <class 'int'> >>> x = 15 >>>x 15 >>> type(x) <class 'int'> >>> 0b1010 10 >>> bin(10) '0b1010' >>> 0o10 8 >>> oct(8) '0o10' >>> 0x145 325 >>> hex(325) '0x145' >>> int(3.5) 3 >>> int(-3.5) -3 >>> int(\"496\") 496 >>> int(\"1000\",3) 27","title":"integer data type"},{"location":"scalartypes/#float-data-type","text":"floating points are supported by float type. python floats are implemented IEEE-754 double-precision with 53-bits of binary precision. This is equivalent to 15-16 significant digits in decimal. >>> 3.125 3.125 >>> 3e8 300000000.0 >>> 1.616e-35 1.616e-35 >>> x = 3.14 >>> x 3.14 >>> type(x) <class 'float'> >>> float(7) 7.0 >>> float(\"1.618\") 1.618 >>> float(\"nan\") nan >>> float(\"inf\") inf >>> float(\"-inf\") -inf >>> 3.0+1 4.0","title":"float data type"},{"location":"scalartypes/#none-data-type","text":"python has special null value called \"None\". None is frequently reprsent the absent of value. >>> None >>> a=None >>> a is None True >>> type(None) <class 'NoneType'>","title":"None data type"},{"location":"scalartypes/#bool-data-type","text":"Boolean logical values used in control structures >>> True True >>> False False >>> bool(0) False >>> bool(42) True >>> bool(-1) True >>> bool(0.0) False >>> bool(0.207) True >>> bool(-1.117) True >>> bool([]) False >>> bool([1,5,9]) True >>> bool(\"\") False >>> bool(\"spam\") True >>> bool(\"False\") True >>> bool(\"True\") True Bool values commonly produces by python relational operators. Relational operators are used to comparing the objects. operator meaning == value equality / equivalence != inequality / inequivalence < less-than > greater-than <= less-than or equal to >= greater-than or equal to >>> g=20 >>> g == 20 True >>> g == 13 False >>> g!= 20 False >>> g < 30 True >>> g <= 20 True >>> g>30 False >>> g >= 20 True","title":"bool data type"},{"location":"scalartypes/#control-flow","text":"","title":"control flow :"},{"location":"scalartypes/#conditional-statement","text":"Branch execution based on the value of an expression. if : Syntax: if expression: block >>> if True: ... print(\"It's true!\") ... It's true! >>> if False: ... print('It's false!') ... >>> if bool('eggs'): ... print('Yes please!') ... Yes please! >>> if \"eggs\": ... print(\"Yes please!\") ... Yes please! else clause: >>> h=42 >>> if h>50: ... print('Greater than 50') ... else: ... print('50 or smaller') 50 or smaller >>> if h > 50 : ... print('Greater than 50') ... else: ... if h<20: ... print('Lessthan 20') ... else: ... print('Between 20 and 50') Between 20 and 50 >>> if h>50: ... print('Greater than 50') ... elif h<20: ... print('less than 50') ... else: ... print('Between 20 and 50') Between 20 and 50 while loops: syntax: while expression: <body> >>> c = 5 >>> while c!=0: ... print(c) ... c-=1 ... 5 4 3 2 1 >>> c=5 >>> while c: ... print(c) ... c-=1 ... 5 4 3 2 1 while loop often used as infinite loops in python. >>> while True: ... pass ... press ctrl+c KeyboardInterrupt break: Many programming languages support a loop ending in predicate test. python rerquires to use while True and break break jumps out of the inner-most executing loop the line immediatley after it. >>> while True: ... response = input() ... if int(response)%7 == 0 : ... break ... 12 24 67 34 28","title":"conditional statement :"},{"location":"scalartypes/#int-truthiness","text":">>> bool(5) == True True >>> bool(4) == True True >>> bool(0) == False False Go back","title":"Int truthiness"},{"location":"scopes/","text":"Variable scopes Local Scope If you declare a variable within a function. You could access the variable value within a function. def f(): x=\"Hello World\" print(x) f()#calling the function print(x) #outside of the function Above function call f() prints Hello World but print(x) in the global scope return us exception x not defined Global Scope def f(): print(s) s = \"Welcome to Python\" #global scope f() #function calling If you call the function f() . It will not give exception but prints Welcome to Python . def f(): s=\"Local scope\" print(s) s = \"Global scope\" #global scope f() print(s) Output: Local scope Global scope But if you try to combine both examples which are mentioned above. def f(): print(s) s = \"Local scope\" print(s) s = \"Global scope\" f() print(s) You will get UnboundLocalError Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 2, in f UnboundLocalError: local variable 's' referenced before assignment As you know python follows LEGB rule, to understand it clearly you need to mention global keyword whenver you want to accesss global varibale in local scope. def f(): global s print(s) s = \"Local scope\" print(s) s = \"Global scope\" f() print(s) output: Global scope Local scope Local scope If you observe the output, it has been replaced golbal varible s value Global scope to Local scope . def f(): s = \"Enclosed function\" def g(): global s s = \"Local function\" print('Before calling g:',s) g() print('After calling g:',s) f() print('value of s',s) Output: Before calling g: Enclosed function After calling g: Enclosed function Value of s, Local function nonlocal nonlocal variables are special kind of variables that cannot change from modules scope. def f(): s = \"enclosing scope\" def g(): nonlocal s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: before calling g enclosing scope after calling g local scope main s global scope def f(): #s = \"enclosing scope\" comment def g(): nonlocal s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: SyntaxError: no binding for nonlocal 's' found But if it is global, it will not give any exception def f(): #s = \"enclosing scope\" comment def g(): global s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: before calling g global scope after calling g local scope main s local scope Home","title":"Variable Scopes"},{"location":"scopes/#variable-scopes","text":"","title":"Variable scopes"},{"location":"scopes/#local-scope","text":"If you declare a variable within a function. You could access the variable value within a function. def f(): x=\"Hello World\" print(x) f()#calling the function print(x) #outside of the function Above function call f() prints Hello World but print(x) in the global scope return us exception x not defined","title":"Local Scope"},{"location":"scopes/#global-scope","text":"def f(): print(s) s = \"Welcome to Python\" #global scope f() #function calling If you call the function f() . It will not give exception but prints Welcome to Python . def f(): s=\"Local scope\" print(s) s = \"Global scope\" #global scope f() print(s) Output: Local scope Global scope But if you try to combine both examples which are mentioned above. def f(): print(s) s = \"Local scope\" print(s) s = \"Global scope\" f() print(s) You will get UnboundLocalError Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 2, in f UnboundLocalError: local variable 's' referenced before assignment As you know python follows LEGB rule, to understand it clearly you need to mention global keyword whenver you want to accesss global varibale in local scope. def f(): global s print(s) s = \"Local scope\" print(s) s = \"Global scope\" f() print(s) output: Global scope Local scope Local scope If you observe the output, it has been replaced golbal varible s value Global scope to Local scope . def f(): s = \"Enclosed function\" def g(): global s s = \"Local function\" print('Before calling g:',s) g() print('After calling g:',s) f() print('value of s',s) Output: Before calling g: Enclosed function After calling g: Enclosed function Value of s, Local function","title":"Global Scope"},{"location":"scopes/#nonlocal","text":"nonlocal variables are special kind of variables that cannot change from modules scope. def f(): s = \"enclosing scope\" def g(): nonlocal s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: before calling g enclosing scope after calling g local scope main s global scope def f(): #s = \"enclosing scope\" comment def g(): nonlocal s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: SyntaxError: no binding for nonlocal 's' found But if it is global, it will not give any exception def f(): #s = \"enclosing scope\" comment def g(): global s s = \"local scope\" print('before calling g',s) g() print('after calling g',s) s = \"global scope\" f() print('main s',s) Output: before calling g global scope after calling g local scope main s local scope Home","title":"nonlocal"},{"location":"template/","text":"You can use the editor on GitHub to maintain and preview the content for your website in Markdown files. Whenever you commit to this repository, GitHub Pages will run Jekyll to rebuild the pages in your site, from the content in your Markdown files. Markdown Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see GitHub Flavored Markdown . Jekyll Themes Your Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings . The name of this theme is saved in the Jekyll _config.yml configuration file. Support or Contact Having trouble with Pages? Check out our documentation or contact support and we\u2019ll help you sort it out.","title":"Template"},{"location":"template/#markdown","text":"Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for Syntax highlighted code block # Header 1 ## Header 2 ### Header 3 - Bulleted - List 1. Numbered 2. List **Bold** and _Italic_ and `Code` text [Link](url) and ![Image](src) For more details see GitHub Flavored Markdown .","title":"Markdown"},{"location":"template/#jekyll-themes","text":"Your Pages site will use the layout and styles from the Jekyll theme you have selected in your repository settings . The name of this theme is saved in the Jekyll _config.yml configuration file.","title":"Jekyll Themes"},{"location":"template/#support-or-contact","text":"Having trouble with Pages? Check out our documentation or contact support and we\u2019ll help you sort it out.","title":"Support or Contact"}]}